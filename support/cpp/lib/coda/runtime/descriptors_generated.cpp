// ============================================================================
// Generated by codagen from descriptors.coda.coda. DO NOT EDIT!
// ============================================================================

#include "coda/types.h"
#include "coda/io/codec.h"
#include "coda/runtime/descriptors_generated.h"
#include "coda/runtime/descriptors_mixin.h"
#include "coda/runtime/descriptors_static.h"

namespace coda {
namespace descriptors {

coda::descriptors::FieldOptions _options0 = coda::descriptors::freeze(coda::descriptors::FieldOptions().setNullable(true));
coda::descriptors::FileOptions _options1 = coda::descriptors::freeze(coda::descriptors::FileOptions().putPackage("java", "coda.descriptors").putPackage("cpp", "coda::descriptors").putPackage("python", "coda.runtime.descdata").putOuterClass("java", "Descriptors").putFilepath("cpp", "coda/runtime/descriptors_generated").putImports("cpp", coda::descriptors::StaticListBuilder<std::string>().add("coda/runtime/descriptors_mixin.h").build()));
coda::descriptors::StructOptions _options2 = coda::descriptors::freeze(coda::descriptors::StructOptions().putMixin("python.python3", "coda.runtime.typemixins.BooleanTypeMixin"));
coda::descriptors::StructOptions _options3 = coda::descriptors::freeze(coda::descriptors::StructOptions().putMixin("python.python3", "coda.runtime.typemixins.BytesTypeMixin"));
coda::descriptors::StructOptions _options4 = coda::descriptors::freeze(coda::descriptors::StructOptions().putMixin("python.python3", "coda.runtime.typemixins.DeclTypeMixin").putMixin("cpp", "coda::descriptors::DeclTypeMixin"));
coda::descriptors::StructOptions _options5 = coda::descriptors::freeze(coda::descriptors::StructOptions().putMixin("python.python3", "coda.runtime.typemixins.DoubleTypeMixin"));
coda::descriptors::StructOptions _options6 = coda::descriptors::freeze(coda::descriptors::StructOptions().putMixin("python.python3", "coda.runtime.typemixins.FloatTypeMixin"));
coda::descriptors::StructOptions _options7 = coda::descriptors::freeze(coda::descriptors::StructOptions().putMixin("python.python3", "coda.runtime.typemixins.IntegerTypeMixin"));
coda::descriptors::StructOptions _options8 = coda::descriptors::freeze(coda::descriptors::StructOptions().putMixin("python.python3", "coda.runtime.typemixins.ListTypeMixin"));
coda::descriptors::StructOptions _options9 = coda::descriptors::freeze(coda::descriptors::StructOptions().putMixin("python.python3", "coda.runtime.typemixins.MapTypeMixin"));
coda::descriptors::StructOptions _options10 = coda::descriptors::freeze(coda::descriptors::StructOptions().putMixin("python.python3", "coda.runtime.typemixins.ModifiedTypeMixin"));
coda::descriptors::StructOptions _options11 = coda::descriptors::freeze(coda::descriptors::StructOptions().putMixin("python.python3", "coda.runtime.typemixins.SetTypeMixin"));
coda::descriptors::StructOptions _options12 = coda::descriptors::freeze(coda::descriptors::StructOptions().putMixin("python.python3", "coda.runtime.typemixins.StringTypeMixin"));
coda::descriptors::StructOptions _options13 = coda::descriptors::freeze(coda::descriptors::StructOptions().putMixin("python.python3", "coda.runtime.typemixins.TypeMixin").putMixin("cpp", "coda::descriptors::TypeMixin").setShared(true));
coda::descriptors::StructOptions _options14 = coda::descriptors::freeze(coda::descriptors::StructOptions().setAllowSubtypes(true));

// ============================================================================
// TypeKind
// ============================================================================

static coda::descriptors::EnumDescriptor::Value TypeKind_Value_TYPE("TYPE", TYPE_KIND_TYPE);
static coda::descriptors::EnumDescriptor::Value TypeKind_Value_BOOL("BOOL", TYPE_KIND_BOOL);
static coda::descriptors::EnumDescriptor::Value TypeKind_Value_INTEGER("INTEGER", TYPE_KIND_INTEGER);
static coda::descriptors::EnumDescriptor::Value TypeKind_Value_FLOAT("FLOAT", TYPE_KIND_FLOAT);
static coda::descriptors::EnumDescriptor::Value TypeKind_Value_DOUBLE("DOUBLE", TYPE_KIND_DOUBLE);
static coda::descriptors::EnumDescriptor::Value TypeKind_Value_STRING("STRING", TYPE_KIND_STRING);
static coda::descriptors::EnumDescriptor::Value TypeKind_Value_BYTES("BYTES", TYPE_KIND_BYTES);
static coda::descriptors::EnumDescriptor::Value TypeKind_Value_LIST("LIST", TYPE_KIND_LIST);
static coda::descriptors::EnumDescriptor::Value TypeKind_Value_SET("SET", TYPE_KIND_SET);
static coda::descriptors::EnumDescriptor::Value TypeKind_Value_MAP("MAP", TYPE_KIND_MAP);
static coda::descriptors::EnumDescriptor::Value TypeKind_Value_MODIFIED("MODIFIED", TYPE_KIND_MODIFIED);
static coda::descriptors::EnumDescriptor::Value TypeKind_Value_STRUCT("STRUCT", TYPE_KIND_STRUCT);
static coda::descriptors::EnumDescriptor::Value TypeKind_Value_ENUM("ENUM", TYPE_KIND_ENUM);
static coda::descriptors::EnumDescriptor::Value TypeKind_Value_EXTERN("EXTERN", TYPE_KIND_EXTERN);
static coda::descriptors::EnumDescriptor::Value TypeKind_Value_COLLECTION("COLLECTION", TYPE_KIND_COLLECTION);
static coda::descriptors::EnumDescriptor::Value TypeKind_Value_DECL("DECL", TYPE_KIND_DECL);

static coda::descriptors::EnumDescriptor::Value* TypeKind_Values[] = {
  &TypeKind_Value_TYPE,
  &TypeKind_Value_BOOL,
  &TypeKind_Value_INTEGER,
  &TypeKind_Value_FLOAT,
  &TypeKind_Value_DOUBLE,
  &TypeKind_Value_STRING,
  &TypeKind_Value_BYTES,
  &TypeKind_Value_LIST,
  &TypeKind_Value_SET,
  &TypeKind_Value_MAP,
  &TypeKind_Value_MODIFIED,
  &TypeKind_Value_STRUCT,
  &TypeKind_Value_ENUM,
  &TypeKind_Value_EXTERN,
  &TypeKind_Value_COLLECTION,
  &TypeKind_Value_DECL,
};

coda::descriptors::EnumDescriptor TypeKind_DESCRIPTOR(
    "TypeKind",
    coda::descriptors::EnumOptions::DEFAULT_INSTANCE,
    TypeKind_Values
);

// ============================================================================
// Value
// ============================================================================

const uint32_t Value::TYPE_ID = 0;

coda::descriptors::StructDescriptor Value::DESCRIPTOR(
  "Value",
  0,
  &Value::DEFAULT_INSTANCE,
  FILE,
  NULL,
  NULL,
  coda::descriptors::StructOptions::DEFAULT_INSTANCE,
  coda::descriptors::StaticArrayRef<coda::descriptors::StructDescriptor*>(),
  coda::descriptors::StaticArrayRef<coda::descriptors::EnumDescriptor*>(),
  coda::descriptors::StaticArrayRef<coda::descriptors::FieldDescriptor*>(),
  &coda::descriptors::StaticObjectBuilder<Value>::create
);

Value Value::DEFAULT_INSTANCE;

// ============================================================================
// BoolValue
// ============================================================================

coda::descriptors::FieldDescriptor BoolValue::Field_value(
    "value", 1,
    coda::types::Boolean::DESCRIPTOR,
    coda::descriptors::FieldOptions::DEFAULT_INSTANCE,
    CODA_OFFSET_OF(BoolValue, _value));

coda::descriptors::FieldDescriptor* BoolValue::Fields[] = {
  &BoolValue::Field_value,
};

const uint32_t BoolValue::TYPE_ID = 1;

coda::descriptors::StructDescriptor BoolValue::DESCRIPTOR(
  "BoolValue",
  1,
  &BoolValue::DEFAULT_INSTANCE,
  FILE,
  NULL,
  &Value::DESCRIPTOR,
  coda::descriptors::StructOptions::DEFAULT_INSTANCE,
  coda::descriptors::StaticArrayRef<coda::descriptors::StructDescriptor*>(),
  coda::descriptors::StaticArrayRef<coda::descriptors::EnumDescriptor*>(),
  BoolValue::Fields,
  &coda::descriptors::StaticObjectBuilder<BoolValue>::create
);

BoolValue BoolValue::DEFAULT_INSTANCE;

bool BoolValue::equals(const coda::runtime::Object* other) const {
  return Value::equals(other) &&
        _value == ((BoolValue*) other)->_value;
}

size_t BoolValue::hashValue() const {
  size_t hash = coda::runtime::Object::hashValue();
  coda::runtime::hash_combine(hash, coda::runtime::hash(_value));
  return hash;
}

void BoolValue::freezeImpl() {
}

void BoolValue::beginWrite(coda::io::Encoder* encoder) const {
  encoder->writeBeginSubtype("BoolValue", coda::descriptors::TYPE_KIND_BOOL);
}

void BoolValue::endWrite(coda::io::Encoder* encoder) const {
  if (hasValue()) {
    encoder->writeFieldHeader("value", 1);
    encoder->writeBoolean(_value);
  }
  encoder->writeEndSubtype();
}

// ============================================================================
// IntegerValue
// ============================================================================

coda::descriptors::FieldDescriptor IntegerValue::Field_value(
    "value", 1,
    coda::types::Integer32::DESCRIPTOR,
    coda::descriptors::FieldOptions::DEFAULT_INSTANCE,
    CODA_OFFSET_OF(IntegerValue, _value));

coda::descriptors::FieldDescriptor* IntegerValue::Fields[] = {
  &IntegerValue::Field_value,
};

const uint32_t IntegerValue::TYPE_ID = 2;

coda::descriptors::StructDescriptor IntegerValue::DESCRIPTOR(
  "IntegerValue",
  2,
  &IntegerValue::DEFAULT_INSTANCE,
  FILE,
  NULL,
  &Value::DESCRIPTOR,
  coda::descriptors::StructOptions::DEFAULT_INSTANCE,
  coda::descriptors::StaticArrayRef<coda::descriptors::StructDescriptor*>(),
  coda::descriptors::StaticArrayRef<coda::descriptors::EnumDescriptor*>(),
  IntegerValue::Fields,
  &coda::descriptors::StaticObjectBuilder<IntegerValue>::create
);

IntegerValue IntegerValue::DEFAULT_INSTANCE;

bool IntegerValue::equals(const coda::runtime::Object* other) const {
  return Value::equals(other) &&
        _value == ((IntegerValue*) other)->_value;
}

size_t IntegerValue::hashValue() const {
  size_t hash = coda::runtime::Object::hashValue();
  coda::runtime::hash_combine(hash, coda::runtime::hash(_value));
  return hash;
}

void IntegerValue::freezeImpl() {
}

void IntegerValue::beginWrite(coda::io::Encoder* encoder) const {
  encoder->writeBeginSubtype("IntegerValue", coda::descriptors::TYPE_KIND_INTEGER);
}

void IntegerValue::endWrite(coda::io::Encoder* encoder) const {
  if (hasValue()) {
    encoder->writeFieldHeader("value", 1);
    encoder->writeInteger(_value);
  }
  encoder->writeEndSubtype();
}

// ============================================================================
// StringValue
// ============================================================================

coda::descriptors::FieldDescriptor StringValue::Field_value(
    "value", 1,
    coda::types::String::DESCRIPTOR,
    coda::descriptors::FieldOptions::DEFAULT_INSTANCE,
    CODA_OFFSET_OF(StringValue, _value));

coda::descriptors::FieldDescriptor* StringValue::Fields[] = {
  &StringValue::Field_value,
};

const uint32_t StringValue::TYPE_ID = 3;

coda::descriptors::StructDescriptor StringValue::DESCRIPTOR(
  "StringValue",
  3,
  &StringValue::DEFAULT_INSTANCE,
  FILE,
  NULL,
  &Value::DESCRIPTOR,
  coda::descriptors::StructOptions::DEFAULT_INSTANCE,
  coda::descriptors::StaticArrayRef<coda::descriptors::StructDescriptor*>(),
  coda::descriptors::StaticArrayRef<coda::descriptors::EnumDescriptor*>(),
  StringValue::Fields,
  &coda::descriptors::StaticObjectBuilder<StringValue>::create
);

StringValue StringValue::DEFAULT_INSTANCE;

bool StringValue::equals(const coda::runtime::Object* other) const {
  return Value::equals(other) &&
        _value == ((StringValue*) other)->_value;
}

size_t StringValue::hashValue() const {
  size_t hash = coda::runtime::Object::hashValue();
  coda::runtime::hash_combine(hash, coda::runtime::hash(_value));
  return hash;
}

void StringValue::freezeImpl() {
}

void StringValue::beginWrite(coda::io::Encoder* encoder) const {
  encoder->writeBeginSubtype("StringValue", coda::descriptors::TYPE_KIND_FLOAT);
}

void StringValue::endWrite(coda::io::Encoder* encoder) const {
  if (hasValue()) {
    encoder->writeFieldHeader("value", 1);
    encoder->writeString(_value);
  }
  encoder->writeEndSubtype();
}

// ============================================================================
// ListValue
// ============================================================================

coda::descriptors::FieldDescriptor ListValue::Field_value(
    "value", 1,
    coda::types::List<Value>::DESCRIPTOR,
    coda::descriptors::FieldOptions::DEFAULT_INSTANCE,
    CODA_OFFSET_OF(ListValue, _value));

coda::descriptors::FieldDescriptor* ListValue::Fields[] = {
  &ListValue::Field_value,
};

const uint32_t ListValue::TYPE_ID = 4;

coda::descriptors::StructDescriptor ListValue::DESCRIPTOR(
  "ListValue",
  4,
  &ListValue::DEFAULT_INSTANCE,
  FILE,
  NULL,
  &Value::DESCRIPTOR,
  coda::descriptors::StructOptions::DEFAULT_INSTANCE,
  coda::descriptors::StaticArrayRef<coda::descriptors::StructDescriptor*>(),
  coda::descriptors::StaticArrayRef<coda::descriptors::EnumDescriptor*>(),
  ListValue::Fields,
  &coda::descriptors::StaticObjectBuilder<ListValue>::create
);

ListValue ListValue::DEFAULT_INSTANCE;

bool ListValue::equals(const coda::runtime::Object* other) const {
  return Value::equals(other) &&
        _value == ((ListValue*) other)->_value;
}

size_t ListValue::hashValue() const {
  size_t hash = coda::runtime::Object::hashValue();
  coda::runtime::hash_combine(hash, coda::runtime::hash(_value));
  return hash;
}

void ListValue::freezeImpl() {
  for (std::vector<Value*>::const_iterator it = _value.begin(), itEnd = _value.end(); it != itEnd; ++it) {
    if ((*it)->isMutable()) {
      (*it)->freeze();
    }
  }
}

void ListValue::beginWrite(coda::io::Encoder* encoder) const {
  encoder->writeBeginSubtype("ListValue", coda::descriptors::TYPE_KIND_DOUBLE);
}

void ListValue::endWrite(coda::io::Encoder* encoder) const {
  if (!_value.empty()) {
    encoder->writeFieldHeader("value", 1);
    encoder->writeBeginList(coda::descriptors::TYPE_KIND_STRUCT, _value.size());
    for (std::vector<Value*>::const_iterator it = _value.begin(), itEnd = _value.end(); it != itEnd; ++it) {
      encoder->writeSharedStruct(*it);
    }
    encoder->writeEndList();
  }
  encoder->writeEndSubtype();
}

// ============================================================================
// Options
// ============================================================================

const uint32_t Options::TYPE_ID = 0;

coda::descriptors::StructDescriptor Options::DESCRIPTOR(
  "Options",
  0,
  &Options::DEFAULT_INSTANCE,
  FILE,
  NULL,
  NULL,
  _options14,
  coda::descriptors::StaticArrayRef<coda::descriptors::StructDescriptor*>(),
  coda::descriptors::StaticArrayRef<coda::descriptors::EnumDescriptor*>(),
  coda::descriptors::StaticArrayRef<coda::descriptors::FieldDescriptor*>(),
  &coda::descriptors::StaticObjectBuilder<Options>::create
);

Options Options::DEFAULT_INSTANCE;

// ============================================================================
// FileOptions
// ============================================================================

coda::descriptors::FieldDescriptor FileOptions::Field_package(
    "package", 1,
    coda::types::Map<coda::types::String, coda::types::String >::DESCRIPTOR,
    coda::descriptors::FieldOptions::DEFAULT_INSTANCE,
    CODA_OFFSET_OF(FileOptions, _package));
coda::descriptors::FieldDescriptor FileOptions::Field_outerClass(
    "outerClass", 3,
    coda::types::Map<coda::types::String, coda::types::String >::DESCRIPTOR,
    coda::descriptors::FieldOptions::DEFAULT_INSTANCE,
    CODA_OFFSET_OF(FileOptions, _outerClass));
coda::descriptors::FieldDescriptor FileOptions::Field_filepath(
    "filepath", 4,
    coda::types::Map<coda::types::String, coda::types::String >::DESCRIPTOR,
    coda::descriptors::FieldOptions::DEFAULT_INSTANCE,
    CODA_OFFSET_OF(FileOptions, _filepath));
coda::descriptors::FieldDescriptor FileOptions::Field_imports(
    "imports", 5,
    coda::types::Map<coda::types::String, coda::types::List<coda::types::String > >::DESCRIPTOR,
    coda::descriptors::FieldOptions::DEFAULT_INSTANCE,
    CODA_OFFSET_OF(FileOptions, _imports));

coda::descriptors::FieldDescriptor* FileOptions::Fields[] = {
  &FileOptions::Field_package,
  &FileOptions::Field_outerClass,
  &FileOptions::Field_filepath,
  &FileOptions::Field_imports,
};

const uint32_t FileOptions::TYPE_ID = 1;

coda::descriptors::StructDescriptor FileOptions::DESCRIPTOR(
  "FileOptions",
  1,
  &FileOptions::DEFAULT_INSTANCE,
  FILE,
  NULL,
  &Options::DESCRIPTOR,
  coda::descriptors::StructOptions::DEFAULT_INSTANCE,
  coda::descriptors::StaticArrayRef<coda::descriptors::StructDescriptor*>(),
  coda::descriptors::StaticArrayRef<coda::descriptors::EnumDescriptor*>(),
  FileOptions::Fields,
  &coda::descriptors::StaticObjectBuilder<FileOptions>::create
);

FileOptions FileOptions::DEFAULT_INSTANCE;

bool FileOptions::equals(const coda::runtime::Object* other) const {
  return Options::equals(other) &&
        _package == ((FileOptions*) other)->_package &&
        _outerClass == ((FileOptions*) other)->_outerClass &&
        _filepath == ((FileOptions*) other)->_filepath &&
        _imports == ((FileOptions*) other)->_imports;
}

size_t FileOptions::hashValue() const {
  size_t hash = coda::runtime::Object::hashValue();
  coda::runtime::hash_combine(hash, coda::runtime::hash(_package));
  coda::runtime::hash_combine(hash, coda::runtime::hash(_outerClass));
  coda::runtime::hash_combine(hash, coda::runtime::hash(_filepath));
  coda::runtime::hash_combine(hash, coda::runtime::hash(_imports));
  return hash;
}

void FileOptions::freezeImpl() {
}

void FileOptions::beginWrite(coda::io::Encoder* encoder) const {
  encoder->writeBeginSubtype("FileOptions", coda::descriptors::TYPE_KIND_BOOL);
}

void FileOptions::endWrite(coda::io::Encoder* encoder) const {
  if (!_package.empty()) {
    encoder->writeFieldHeader("package", 1);
    encoder->writeBeginMap(coda::descriptors::TYPE_KIND_STRING, coda::descriptors::TYPE_KIND_STRING, _package.size());
    for (std::unordered_map<std::string, std::string >::const_iterator it = _package.begin(), itEnd = _package.end(); it != itEnd; ++it) {
      encoder->writeString(it->first);
      encoder->writeString(it->second);
    }
    encoder->writeEndMap();
  }
  if (!_outerClass.empty()) {
    encoder->writeFieldHeader("outerClass", 3);
    encoder->writeBeginMap(coda::descriptors::TYPE_KIND_STRING, coda::descriptors::TYPE_KIND_STRING, _outerClass.size());
    for (std::unordered_map<std::string, std::string >::const_iterator it = _outerClass.begin(), itEnd = _outerClass.end(); it != itEnd; ++it) {
      encoder->writeString(it->first);
      encoder->writeString(it->second);
    }
    encoder->writeEndMap();
  }
  if (!_filepath.empty()) {
    encoder->writeFieldHeader("filepath", 4);
    encoder->writeBeginMap(coda::descriptors::TYPE_KIND_STRING, coda::descriptors::TYPE_KIND_STRING, _filepath.size());
    for (std::unordered_map<std::string, std::string >::const_iterator it = _filepath.begin(), itEnd = _filepath.end(); it != itEnd; ++it) {
      encoder->writeString(it->first);
      encoder->writeString(it->second);
    }
    encoder->writeEndMap();
  }
  if (!_imports.empty()) {
    encoder->writeFieldHeader("imports", 5);
    encoder->writeBeginMap(coda::descriptors::TYPE_KIND_STRING, coda::descriptors::TYPE_KIND_LIST, _imports.size());
    for (std::unordered_map<std::string, std::vector<std::string> >::const_iterator it = _imports.begin(), itEnd = _imports.end(); it != itEnd; ++it) {
      encoder->writeString(it->first);
      encoder->writeBeginList(coda::descriptors::TYPE_KIND_STRING, it->second.size());
      for (std::vector<std::string>::const_iterator i1 = it->second.begin(), i1End = it->second.end(); i1 != i1End; ++i1) {
        encoder->writeString(*i1);
      }
      encoder->writeEndList();
    }
    encoder->writeEndMap();
  }
  encoder->writeEndSubtype();
}

// ============================================================================
// StructOptions
// ============================================================================

coda::descriptors::FieldDescriptor StructOptions::Field_allowSubtypes(
    "allowSubtypes", 1,
    coda::types::Boolean::DESCRIPTOR,
    coda::descriptors::FieldOptions::DEFAULT_INSTANCE,
    CODA_OFFSET_OF(StructOptions, _allowSubtypes));
coda::descriptors::FieldDescriptor StructOptions::Field_genClassName(
    "genClassName", 2,
    coda::types::Map<coda::types::String, coda::types::String >::DESCRIPTOR,
    coda::descriptors::FieldOptions::DEFAULT_INSTANCE,
    CODA_OFFSET_OF(StructOptions, _genClassName));
coda::descriptors::FieldDescriptor StructOptions::Field_mixin(
    "mixin", 3,
    coda::types::Map<coda::types::String, coda::types::String >::DESCRIPTOR,
    coda::descriptors::FieldOptions::DEFAULT_INSTANCE,
    CODA_OFFSET_OF(StructOptions, _mixin));
coda::descriptors::FieldDescriptor StructOptions::Field_reference(
    "reference", 4,
    coda::types::Boolean::DESCRIPTOR,
    coda::descriptors::FieldOptions::DEFAULT_INSTANCE,
    CODA_OFFSET_OF(StructOptions, _reference));
coda::descriptors::FieldDescriptor StructOptions::Field_shared(
    "shared", 5,
    coda::types::Boolean::DESCRIPTOR,
    coda::descriptors::FieldOptions::DEFAULT_INSTANCE,
    CODA_OFFSET_OF(StructOptions, _shared));

coda::descriptors::FieldDescriptor* StructOptions::Fields[] = {
  &StructOptions::Field_allowSubtypes,
  &StructOptions::Field_genClassName,
  &StructOptions::Field_mixin,
  &StructOptions::Field_reference,
  &StructOptions::Field_shared,
};

const uint32_t StructOptions::TYPE_ID = 2;

coda::descriptors::StructDescriptor StructOptions::DESCRIPTOR(
  "StructOptions",
  2,
  &StructOptions::DEFAULT_INSTANCE,
  FILE,
  NULL,
  &Options::DESCRIPTOR,
  coda::descriptors::StructOptions::DEFAULT_INSTANCE,
  coda::descriptors::StaticArrayRef<coda::descriptors::StructDescriptor*>(),
  coda::descriptors::StaticArrayRef<coda::descriptors::EnumDescriptor*>(),
  StructOptions::Fields,
  &coda::descriptors::StaticObjectBuilder<StructOptions>::create
);

StructOptions StructOptions::DEFAULT_INSTANCE;

bool StructOptions::equals(const coda::runtime::Object* other) const {
  return Options::equals(other) &&
        _allowSubtypes == ((StructOptions*) other)->_allowSubtypes &&
        _genClassName == ((StructOptions*) other)->_genClassName &&
        _mixin == ((StructOptions*) other)->_mixin &&
        _reference == ((StructOptions*) other)->_reference &&
        _shared == ((StructOptions*) other)->_shared;
}

size_t StructOptions::hashValue() const {
  size_t hash = coda::runtime::Object::hashValue();
  coda::runtime::hash_combine(hash, coda::runtime::hash(_allowSubtypes));
  coda::runtime::hash_combine(hash, coda::runtime::hash(_genClassName));
  coda::runtime::hash_combine(hash, coda::runtime::hash(_mixin));
  coda::runtime::hash_combine(hash, coda::runtime::hash(_reference));
  coda::runtime::hash_combine(hash, coda::runtime::hash(_shared));
  return hash;
}

void StructOptions::freezeImpl() {
}

void StructOptions::beginWrite(coda::io::Encoder* encoder) const {
  encoder->writeBeginSubtype("StructOptions", coda::descriptors::TYPE_KIND_INTEGER);
}

void StructOptions::endWrite(coda::io::Encoder* encoder) const {
  if (hasAllowSubtypes()) {
    encoder->writeFieldHeader("allowSubtypes", 1);
    encoder->writeBoolean(_allowSubtypes);
  }
  if (!_genClassName.empty()) {
    encoder->writeFieldHeader("genClassName", 2);
    encoder->writeBeginMap(coda::descriptors::TYPE_KIND_STRING, coda::descriptors::TYPE_KIND_STRING, _genClassName.size());
    for (std::unordered_map<std::string, std::string >::const_iterator it = _genClassName.begin(), itEnd = _genClassName.end(); it != itEnd; ++it) {
      encoder->writeString(it->first);
      encoder->writeString(it->second);
    }
    encoder->writeEndMap();
  }
  if (!_mixin.empty()) {
    encoder->writeFieldHeader("mixin", 3);
    encoder->writeBeginMap(coda::descriptors::TYPE_KIND_STRING, coda::descriptors::TYPE_KIND_STRING, _mixin.size());
    for (std::unordered_map<std::string, std::string >::const_iterator it = _mixin.begin(), itEnd = _mixin.end(); it != itEnd; ++it) {
      encoder->writeString(it->first);
      encoder->writeString(it->second);
    }
    encoder->writeEndMap();
  }
  if (hasReference()) {
    encoder->writeFieldHeader("reference", 4);
    encoder->writeBoolean(_reference);
  }
  if (hasShared()) {
    encoder->writeFieldHeader("shared", 5);
    encoder->writeBoolean(_shared);
  }
  encoder->writeEndSubtype();
}

// ============================================================================
// FieldOptions
// ============================================================================

coda::descriptors::FieldDescriptor FieldOptions::Field_nullable(
    "nullable", 1,
    coda::types::Boolean::DESCRIPTOR,
    coda::descriptors::FieldOptions::DEFAULT_INSTANCE,
    CODA_OFFSET_OF(FieldOptions, _nullable));
coda::descriptors::FieldDescriptor FieldOptions::Field_deprecated(
    "deprecated", 3,
    coda::types::Boolean::DESCRIPTOR,
    coda::descriptors::FieldOptions::DEFAULT_INSTANCE,
    CODA_OFFSET_OF(FieldOptions, _deprecated));
coda::descriptors::FieldDescriptor FieldOptions::Field_fixed(
    "fixed", 4,
    coda::types::Boolean::DESCRIPTOR,
    coda::descriptors::FieldOptions::DEFAULT_INSTANCE,
    CODA_OFFSET_OF(FieldOptions, _fixed));
coda::descriptors::FieldDescriptor FieldOptions::Field_transient(
    "transient", 5,
    coda::types::Boolean::DESCRIPTOR,
    coda::descriptors::FieldOptions::DEFAULT_INSTANCE,
    CODA_OFFSET_OF(FieldOptions, _transient));
coda::descriptors::FieldDescriptor FieldOptions::Field_ignore(
    "ignore", 6,
    coda::types::Map<coda::types::String, coda::types::Boolean>::DESCRIPTOR,
    coda::descriptors::FieldOptions::DEFAULT_INSTANCE,
    CODA_OFFSET_OF(FieldOptions, _ignore));
coda::descriptors::FieldDescriptor FieldOptions::Field_default(
    "default", 7,
    Value::DESCRIPTOR,
    _options0,
    CODA_OFFSET_OF(FieldOptions, _default));
coda::descriptors::FieldDescriptor FieldOptions::Field_novisit(
    "novisit", 8,
    coda::types::Boolean::DESCRIPTOR,
    coda::descriptors::FieldOptions::DEFAULT_INSTANCE,
    CODA_OFFSET_OF(FieldOptions, _novisit));

coda::descriptors::FieldDescriptor* FieldOptions::Fields[] = {
  &FieldOptions::Field_nullable,
  &FieldOptions::Field_deprecated,
  &FieldOptions::Field_fixed,
  &FieldOptions::Field_transient,
  &FieldOptions::Field_ignore,
  &FieldOptions::Field_default,
  &FieldOptions::Field_novisit,
};

const uint32_t FieldOptions::TYPE_ID = 3;

coda::descriptors::StructDescriptor FieldOptions::DESCRIPTOR(
  "FieldOptions",
  3,
  &FieldOptions::DEFAULT_INSTANCE,
  FILE,
  NULL,
  &Options::DESCRIPTOR,
  coda::descriptors::StructOptions::DEFAULT_INSTANCE,
  coda::descriptors::StaticArrayRef<coda::descriptors::StructDescriptor*>(),
  coda::descriptors::StaticArrayRef<coda::descriptors::EnumDescriptor*>(),
  FieldOptions::Fields,
  &coda::descriptors::StaticObjectBuilder<FieldOptions>::create
);

FieldOptions FieldOptions::DEFAULT_INSTANCE;

bool FieldOptions::equals(const coda::runtime::Object* other) const {
  return Options::equals(other) &&
        _nullable == ((FieldOptions*) other)->_nullable &&
        _deprecated == ((FieldOptions*) other)->_deprecated &&
        _fixed == ((FieldOptions*) other)->_fixed &&
        _transient == ((FieldOptions*) other)->_transient &&
        _ignore == ((FieldOptions*) other)->_ignore &&
        _default == ((FieldOptions*) other)->_default &&
        _novisit == ((FieldOptions*) other)->_novisit;
}

size_t FieldOptions::hashValue() const {
  size_t hash = coda::runtime::Object::hashValue();
  coda::runtime::hash_combine(hash, coda::runtime::hash(_nullable));
  coda::runtime::hash_combine(hash, coda::runtime::hash(_deprecated));
  coda::runtime::hash_combine(hash, coda::runtime::hash(_fixed));
  coda::runtime::hash_combine(hash, coda::runtime::hash(_transient));
  coda::runtime::hash_combine(hash, coda::runtime::hash(_ignore));
  coda::runtime::hash_combine(hash, coda::runtime::hash(_default));
  coda::runtime::hash_combine(hash, coda::runtime::hash(_novisit));
  return hash;
}

void FieldOptions::freezeImpl() {
  if (_default && _default->isMutable()) {
    _default->freeze();
  }
}

void FieldOptions::beginWrite(coda::io::Encoder* encoder) const {
  encoder->writeBeginSubtype("FieldOptions", coda::descriptors::TYPE_KIND_FLOAT);
}

void FieldOptions::endWrite(coda::io::Encoder* encoder) const {
  if (hasNullable()) {
    encoder->writeFieldHeader("nullable", 1);
    encoder->writeBoolean(_nullable);
  }
  if (hasDeprecated()) {
    encoder->writeFieldHeader("deprecated", 3);
    encoder->writeBoolean(_deprecated);
  }
  if (hasFixed()) {
    encoder->writeFieldHeader("fixed", 4);
    encoder->writeBoolean(_fixed);
  }
  if (hasTransient()) {
    encoder->writeFieldHeader("transient", 5);
    encoder->writeBoolean(_transient);
  }
  if (!_ignore.empty()) {
    encoder->writeFieldHeader("ignore", 6);
    encoder->writeBeginMap(coda::descriptors::TYPE_KIND_STRING, coda::descriptors::TYPE_KIND_BOOL, _ignore.size());
    for (std::unordered_map<std::string, bool>::const_iterator it = _ignore.begin(), itEnd = _ignore.end(); it != itEnd; ++it) {
      encoder->writeString(it->first);
      encoder->writeBoolean(it->second);
    }
    encoder->writeEndMap();
  }
  if (hasDefault()) {
    encoder->writeFieldHeader("default", 7);
    encoder->writeSharedStruct(_default);
  }
  if (hasNovisit()) {
    encoder->writeFieldHeader("novisit", 8);
    encoder->writeBoolean(_novisit);
  }
  encoder->writeEndSubtype();
}

// ============================================================================
// MethodOptions
// ============================================================================

coda::descriptors::FieldDescriptor MethodOptions::Field_const(
    "const", 4,
    coda::types::Boolean::DESCRIPTOR,
    coda::descriptors::FieldOptions::DEFAULT_INSTANCE,
    CODA_OFFSET_OF(MethodOptions, _const));

coda::descriptors::FieldDescriptor* MethodOptions::Fields[] = {
  &MethodOptions::Field_const,
};

const uint32_t MethodOptions::TYPE_ID = 4;

coda::descriptors::StructDescriptor MethodOptions::DESCRIPTOR(
  "MethodOptions",
  4,
  &MethodOptions::DEFAULT_INSTANCE,
  FILE,
  NULL,
  &Options::DESCRIPTOR,
  coda::descriptors::StructOptions::DEFAULT_INSTANCE,
  coda::descriptors::StaticArrayRef<coda::descriptors::StructDescriptor*>(),
  coda::descriptors::StaticArrayRef<coda::descriptors::EnumDescriptor*>(),
  MethodOptions::Fields,
  &coda::descriptors::StaticObjectBuilder<MethodOptions>::create
);

MethodOptions MethodOptions::DEFAULT_INSTANCE;

bool MethodOptions::equals(const coda::runtime::Object* other) const {
  return Options::equals(other) &&
        _const == ((MethodOptions*) other)->_const;
}

size_t MethodOptions::hashValue() const {
  size_t hash = coda::runtime::Object::hashValue();
  coda::runtime::hash_combine(hash, coda::runtime::hash(_const));
  return hash;
}

void MethodOptions::freezeImpl() {
}

void MethodOptions::beginWrite(coda::io::Encoder* encoder) const {
  encoder->writeBeginSubtype("MethodOptions", coda::descriptors::TYPE_KIND_DOUBLE);
}

void MethodOptions::endWrite(coda::io::Encoder* encoder) const {
  if (hasConst()) {
    encoder->writeFieldHeader("const", 4);
    encoder->writeBoolean(_const);
  }
  encoder->writeEndSubtype();
}

// ============================================================================
// EnumOptions
// ============================================================================

const uint32_t EnumOptions::TYPE_ID = 5;

coda::descriptors::StructDescriptor EnumOptions::DESCRIPTOR(
  "EnumOptions",
  5,
  &EnumOptions::DEFAULT_INSTANCE,
  FILE,
  NULL,
  &Options::DESCRIPTOR,
  coda::descriptors::StructOptions::DEFAULT_INSTANCE,
  coda::descriptors::StaticArrayRef<coda::descriptors::StructDescriptor*>(),
  coda::descriptors::StaticArrayRef<coda::descriptors::EnumDescriptor*>(),
  coda::descriptors::StaticArrayRef<coda::descriptors::FieldDescriptor*>(),
  &coda::descriptors::StaticObjectBuilder<EnumOptions>::create
);

EnumOptions EnumOptions::DEFAULT_INSTANCE;

void EnumOptions::beginWrite(coda::io::Encoder* encoder) const {
  encoder->writeBeginSubtype("EnumOptions", coda::descriptors::TYPE_KIND_STRING);
}

void EnumOptions::endWrite(coda::io::Encoder* encoder) const {
  encoder->writeEndSubtype();
}

// ============================================================================
// Type
// ============================================================================

const uint32_t Type::TYPE_ID = 0;

coda::descriptors::StructDescriptor Type::DESCRIPTOR(
  "Type",
  0,
  &Type::DEFAULT_INSTANCE,
  FILE,
  NULL,
  NULL,
  _options13,
  coda::descriptors::StaticArrayRef<coda::descriptors::StructDescriptor*>(),
  coda::descriptors::StaticArrayRef<coda::descriptors::EnumDescriptor*>(),
  coda::descriptors::StaticArrayRef<coda::descriptors::FieldDescriptor*>(),
  &coda::descriptors::StaticObjectBuilder<Type>::create
);

Type Type::DEFAULT_INSTANCE;

// ============================================================================
// BooleanType
// ============================================================================

const uint32_t BooleanType::TYPE_ID = 1;

coda::descriptors::StructDescriptor BooleanType::DESCRIPTOR(
  "BooleanType",
  1,
  &BooleanType::DEFAULT_INSTANCE,
  FILE,
  NULL,
  &Type::DESCRIPTOR,
  _options2,
  coda::descriptors::StaticArrayRef<coda::descriptors::StructDescriptor*>(),
  coda::descriptors::StaticArrayRef<coda::descriptors::EnumDescriptor*>(),
  coda::descriptors::StaticArrayRef<coda::descriptors::FieldDescriptor*>(),
  &coda::descriptors::StaticObjectBuilder<BooleanType>::create
);

BooleanType BooleanType::DEFAULT_INSTANCE;

void BooleanType::beginWrite(coda::io::Encoder* encoder) const {
  encoder->writeBeginSubtype("BooleanType", coda::descriptors::TYPE_KIND_BOOL);
}

void BooleanType::endWrite(coda::io::Encoder* encoder) const {
  encoder->writeEndSubtype();
}

// ============================================================================
// IntegerType
// ============================================================================

coda::descriptors::FieldDescriptor IntegerType::Field_bits(
    "bits", 1,
    coda::types::Integer32::DESCRIPTOR,
    coda::descriptors::FieldOptions::DEFAULT_INSTANCE,
    CODA_OFFSET_OF(IntegerType, _bits));

coda::descriptors::FieldDescriptor* IntegerType::Fields[] = {
  &IntegerType::Field_bits,
};

const uint32_t IntegerType::TYPE_ID = 2;

coda::descriptors::StructDescriptor IntegerType::DESCRIPTOR(
  "IntegerType",
  2,
  &IntegerType::DEFAULT_INSTANCE,
  FILE,
  NULL,
  &Type::DESCRIPTOR,
  _options7,
  coda::descriptors::StaticArrayRef<coda::descriptors::StructDescriptor*>(),
  coda::descriptors::StaticArrayRef<coda::descriptors::EnumDescriptor*>(),
  IntegerType::Fields,
  &coda::descriptors::StaticObjectBuilder<IntegerType>::create
);

IntegerType IntegerType::DEFAULT_INSTANCE;

bool IntegerType::equals(const coda::runtime::Object* other) const {
  return Type::equals(other) &&
        _bits == ((IntegerType*) other)->_bits;
}

size_t IntegerType::hashValue() const {
  size_t hash = coda::runtime::Object::hashValue();
  coda::runtime::hash_combine(hash, coda::runtime::hash(_bits));
  return hash;
}

void IntegerType::freezeImpl() {
}

void IntegerType::beginWrite(coda::io::Encoder* encoder) const {
  encoder->writeBeginSubtype("IntegerType", coda::descriptors::TYPE_KIND_INTEGER);
}

void IntegerType::endWrite(coda::io::Encoder* encoder) const {
  if (hasBits()) {
    encoder->writeFieldHeader("bits", 1);
    encoder->writeInteger(_bits);
  }
  encoder->writeEndSubtype();
}

// ============================================================================
// FloatType
// ============================================================================

const uint32_t FloatType::TYPE_ID = 3;

coda::descriptors::StructDescriptor FloatType::DESCRIPTOR(
  "FloatType",
  3,
  &FloatType::DEFAULT_INSTANCE,
  FILE,
  NULL,
  &Type::DESCRIPTOR,
  _options6,
  coda::descriptors::StaticArrayRef<coda::descriptors::StructDescriptor*>(),
  coda::descriptors::StaticArrayRef<coda::descriptors::EnumDescriptor*>(),
  coda::descriptors::StaticArrayRef<coda::descriptors::FieldDescriptor*>(),
  &coda::descriptors::StaticObjectBuilder<FloatType>::create
);

FloatType FloatType::DEFAULT_INSTANCE;

void FloatType::beginWrite(coda::io::Encoder* encoder) const {
  encoder->writeBeginSubtype("FloatType", coda::descriptors::TYPE_KIND_FLOAT);
}

void FloatType::endWrite(coda::io::Encoder* encoder) const {
  encoder->writeEndSubtype();
}

// ============================================================================
// DoubleType
// ============================================================================

const uint32_t DoubleType::TYPE_ID = 4;

coda::descriptors::StructDescriptor DoubleType::DESCRIPTOR(
  "DoubleType",
  4,
  &DoubleType::DEFAULT_INSTANCE,
  FILE,
  NULL,
  &Type::DESCRIPTOR,
  _options5,
  coda::descriptors::StaticArrayRef<coda::descriptors::StructDescriptor*>(),
  coda::descriptors::StaticArrayRef<coda::descriptors::EnumDescriptor*>(),
  coda::descriptors::StaticArrayRef<coda::descriptors::FieldDescriptor*>(),
  &coda::descriptors::StaticObjectBuilder<DoubleType>::create
);

DoubleType DoubleType::DEFAULT_INSTANCE;

void DoubleType::beginWrite(coda::io::Encoder* encoder) const {
  encoder->writeBeginSubtype("DoubleType", coda::descriptors::TYPE_KIND_DOUBLE);
}

void DoubleType::endWrite(coda::io::Encoder* encoder) const {
  encoder->writeEndSubtype();
}

// ============================================================================
// StringType
// ============================================================================

const uint32_t StringType::TYPE_ID = 5;

coda::descriptors::StructDescriptor StringType::DESCRIPTOR(
  "StringType",
  5,
  &StringType::DEFAULT_INSTANCE,
  FILE,
  NULL,
  &Type::DESCRIPTOR,
  _options12,
  coda::descriptors::StaticArrayRef<coda::descriptors::StructDescriptor*>(),
  coda::descriptors::StaticArrayRef<coda::descriptors::EnumDescriptor*>(),
  coda::descriptors::StaticArrayRef<coda::descriptors::FieldDescriptor*>(),
  &coda::descriptors::StaticObjectBuilder<StringType>::create
);

StringType StringType::DEFAULT_INSTANCE;

void StringType::beginWrite(coda::io::Encoder* encoder) const {
  encoder->writeBeginSubtype("StringType", coda::descriptors::TYPE_KIND_STRING);
}

void StringType::endWrite(coda::io::Encoder* encoder) const {
  encoder->writeEndSubtype();
}

// ============================================================================
// BytesType
// ============================================================================

const uint32_t BytesType::TYPE_ID = 6;

coda::descriptors::StructDescriptor BytesType::DESCRIPTOR(
  "BytesType",
  6,
  &BytesType::DEFAULT_INSTANCE,
  FILE,
  NULL,
  &Type::DESCRIPTOR,
  _options3,
  coda::descriptors::StaticArrayRef<coda::descriptors::StructDescriptor*>(),
  coda::descriptors::StaticArrayRef<coda::descriptors::EnumDescriptor*>(),
  coda::descriptors::StaticArrayRef<coda::descriptors::FieldDescriptor*>(),
  &coda::descriptors::StaticObjectBuilder<BytesType>::create
);

BytesType BytesType::DEFAULT_INSTANCE;

void BytesType::beginWrite(coda::io::Encoder* encoder) const {
  encoder->writeBeginSubtype("BytesType", coda::descriptors::TYPE_KIND_BYTES);
}

void BytesType::endWrite(coda::io::Encoder* encoder) const {
  encoder->writeEndSubtype();
}

// ============================================================================
// CollectionType
// ============================================================================

const uint32_t CollectionType::TYPE_ID = 40;

coda::descriptors::StructDescriptor CollectionType::DESCRIPTOR(
  "CollectionType",
  40,
  &CollectionType::DEFAULT_INSTANCE,
  FILE,
  NULL,
  &Type::DESCRIPTOR,
  coda::descriptors::StructOptions::DEFAULT_INSTANCE,
  coda::descriptors::StaticArrayRef<coda::descriptors::StructDescriptor*>(),
  coda::descriptors::StaticArrayRef<coda::descriptors::EnumDescriptor*>(),
  coda::descriptors::StaticArrayRef<coda::descriptors::FieldDescriptor*>(),
  &coda::descriptors::StaticObjectBuilder<CollectionType>::create
);

CollectionType CollectionType::DEFAULT_INSTANCE;

void CollectionType::beginWrite(coda::io::Encoder* encoder) const {
  encoder->writeBeginSubtype("CollectionType", coda::descriptors::TYPE_KIND_COLLECTION);
}

void CollectionType::endWrite(coda::io::Encoder* encoder) const {
  encoder->writeEndSubtype();
}

// ============================================================================
// ListType
// ============================================================================

coda::descriptors::FieldDescriptor ListType::Field_elementType(
    "elementType", 1,
    coda::types::Modified<Type, false, true>::DESCRIPTOR,
    coda::descriptors::FieldOptions::DEFAULT_INSTANCE,
    CODA_OFFSET_OF(ListType, _elementType));

coda::descriptors::FieldDescriptor* ListType::Fields[] = {
  &ListType::Field_elementType,
};

const uint32_t ListType::TYPE_ID = 20;

coda::descriptors::StructDescriptor ListType::DESCRIPTOR(
  "ListType",
  20,
  &ListType::DEFAULT_INSTANCE,
  FILE,
  NULL,
  &CollectionType::DESCRIPTOR,
  _options8,
  coda::descriptors::StaticArrayRef<coda::descriptors::StructDescriptor*>(),
  coda::descriptors::StaticArrayRef<coda::descriptors::EnumDescriptor*>(),
  ListType::Fields,
  &coda::descriptors::StaticObjectBuilder<ListType>::create
);

ListType ListType::DEFAULT_INSTANCE;

ListType::ListType()
  : _elementType(NULL)
{
}

bool ListType::equals(const coda::runtime::Object* other) const {
  return CollectionType::equals(other) &&
        _elementType == ((ListType*) other)->_elementType;
}

size_t ListType::hashValue() const {
  size_t hash = coda::runtime::Object::hashValue();
  coda::runtime::hash_combine(hash, coda::runtime::hash(_elementType));
  return hash;
}

void ListType::freezeImpl() {
  if (_elementType->isMutable()) {
    _elementType->freeze();
  }
}

void ListType::beginWrite(coda::io::Encoder* encoder) const {
  encoder->writeBeginSubtype("ListType", coda::descriptors::TYPE_KIND_LIST);
}

void ListType::endWrite(coda::io::Encoder* encoder) const {
  if (hasElementType()) {
    encoder->writeFieldHeader("elementType", 1);
    encoder->writeSharedStruct(_elementType);
  }
  encoder->writeEndSubtype();
}

// ============================================================================
// SetType
// ============================================================================

coda::descriptors::FieldDescriptor SetType::Field_elementType(
    "elementType", 1,
    coda::types::Modified<Type, false, true>::DESCRIPTOR,
    coda::descriptors::FieldOptions::DEFAULT_INSTANCE,
    CODA_OFFSET_OF(SetType, _elementType));

coda::descriptors::FieldDescriptor* SetType::Fields[] = {
  &SetType::Field_elementType,
};

const uint32_t SetType::TYPE_ID = 21;

coda::descriptors::StructDescriptor SetType::DESCRIPTOR(
  "SetType",
  21,
  &SetType::DEFAULT_INSTANCE,
  FILE,
  NULL,
  &CollectionType::DESCRIPTOR,
  _options11,
  coda::descriptors::StaticArrayRef<coda::descriptors::StructDescriptor*>(),
  coda::descriptors::StaticArrayRef<coda::descriptors::EnumDescriptor*>(),
  SetType::Fields,
  &coda::descriptors::StaticObjectBuilder<SetType>::create
);

SetType SetType::DEFAULT_INSTANCE;

SetType::SetType()
  : _elementType(NULL)
{
}

bool SetType::equals(const coda::runtime::Object* other) const {
  return CollectionType::equals(other) &&
        _elementType == ((SetType*) other)->_elementType;
}

size_t SetType::hashValue() const {
  size_t hash = coda::runtime::Object::hashValue();
  coda::runtime::hash_combine(hash, coda::runtime::hash(_elementType));
  return hash;
}

void SetType::freezeImpl() {
  if (_elementType->isMutable()) {
    _elementType->freeze();
  }
}

void SetType::beginWrite(coda::io::Encoder* encoder) const {
  encoder->writeBeginSubtype("SetType", coda::descriptors::TYPE_KIND_SET);
}

void SetType::endWrite(coda::io::Encoder* encoder) const {
  if (hasElementType()) {
    encoder->writeFieldHeader("elementType", 1);
    encoder->writeSharedStruct(_elementType);
  }
  encoder->writeEndSubtype();
}

// ============================================================================
// MapType
// ============================================================================

coda::descriptors::FieldDescriptor MapType::Field_keyType(
    "keyType", 1,
    coda::types::Modified<Type, false, true>::DESCRIPTOR,
    coda::descriptors::FieldOptions::DEFAULT_INSTANCE,
    CODA_OFFSET_OF(MapType, _keyType));
coda::descriptors::FieldDescriptor MapType::Field_valueType(
    "valueType", 2,
    coda::types::Modified<Type, false, true>::DESCRIPTOR,
    coda::descriptors::FieldOptions::DEFAULT_INSTANCE,
    CODA_OFFSET_OF(MapType, _valueType));

coda::descriptors::FieldDescriptor* MapType::Fields[] = {
  &MapType::Field_keyType,
  &MapType::Field_valueType,
};

const uint32_t MapType::TYPE_ID = 22;

coda::descriptors::StructDescriptor MapType::DESCRIPTOR(
  "MapType",
  22,
  &MapType::DEFAULT_INSTANCE,
  FILE,
  NULL,
  &CollectionType::DESCRIPTOR,
  _options9,
  coda::descriptors::StaticArrayRef<coda::descriptors::StructDescriptor*>(),
  coda::descriptors::StaticArrayRef<coda::descriptors::EnumDescriptor*>(),
  MapType::Fields,
  &coda::descriptors::StaticObjectBuilder<MapType>::create
);

MapType MapType::DEFAULT_INSTANCE;

MapType::MapType()
  : _keyType(NULL)
  , _valueType(NULL)
{
}

bool MapType::equals(const coda::runtime::Object* other) const {
  return CollectionType::equals(other) &&
        _keyType == ((MapType*) other)->_keyType &&
        _valueType == ((MapType*) other)->_valueType;
}

size_t MapType::hashValue() const {
  size_t hash = coda::runtime::Object::hashValue();
  coda::runtime::hash_combine(hash, coda::runtime::hash(_keyType));
  coda::runtime::hash_combine(hash, coda::runtime::hash(_valueType));
  return hash;
}

void MapType::freezeImpl() {
  if (_keyType->isMutable()) {
    _keyType->freeze();
  }
  if (_valueType->isMutable()) {
    _valueType->freeze();
  }
}

void MapType::beginWrite(coda::io::Encoder* encoder) const {
  encoder->writeBeginSubtype("MapType", coda::descriptors::TYPE_KIND_MAP);
}

void MapType::endWrite(coda::io::Encoder* encoder) const {
  if (hasKeyType()) {
    encoder->writeFieldHeader("keyType", 1);
    encoder->writeSharedStruct(_keyType);
  }
  if (hasValueType()) {
    encoder->writeFieldHeader("valueType", 2);
    encoder->writeSharedStruct(_valueType);
  }
  encoder->writeEndSubtype();
}

// ============================================================================
// ModifiedType
// ============================================================================

coda::descriptors::FieldDescriptor ModifiedType::Field_elementType(
    "elementType", 1,
    coda::types::Modified<Type, false, true>::DESCRIPTOR,
    coda::descriptors::FieldOptions::DEFAULT_INSTANCE,
    CODA_OFFSET_OF(ModifiedType, _elementType));
coda::descriptors::FieldDescriptor ModifiedType::Field_const(
    "const", 2,
    coda::types::Boolean::DESCRIPTOR,
    coda::descriptors::FieldOptions::DEFAULT_INSTANCE,
    CODA_OFFSET_OF(ModifiedType, _const));
coda::descriptors::FieldDescriptor ModifiedType::Field_shared(
    "shared", 3,
    coda::types::Boolean::DESCRIPTOR,
    coda::descriptors::FieldOptions::DEFAULT_INSTANCE,
    CODA_OFFSET_OF(ModifiedType, _shared));

coda::descriptors::FieldDescriptor* ModifiedType::Fields[] = {
  &ModifiedType::Field_elementType,
  &ModifiedType::Field_const,
  &ModifiedType::Field_shared,
};

const uint32_t ModifiedType::TYPE_ID = 23;

coda::descriptors::StructDescriptor ModifiedType::DESCRIPTOR(
  "ModifiedType",
  23,
  &ModifiedType::DEFAULT_INSTANCE,
  FILE,
  NULL,
  &Type::DESCRIPTOR,
  _options10,
  coda::descriptors::StaticArrayRef<coda::descriptors::StructDescriptor*>(),
  coda::descriptors::StaticArrayRef<coda::descriptors::EnumDescriptor*>(),
  ModifiedType::Fields,
  &coda::descriptors::StaticObjectBuilder<ModifiedType>::create
);

ModifiedType ModifiedType::DEFAULT_INSTANCE;

ModifiedType::ModifiedType()
  : _elementType(NULL)
  , _const(false)
  , _shared(false)
{
}

bool ModifiedType::equals(const coda::runtime::Object* other) const {
  return Type::equals(other) &&
        _elementType == ((ModifiedType*) other)->_elementType &&
        _const == ((ModifiedType*) other)->_const &&
        _shared == ((ModifiedType*) other)->_shared;
}

size_t ModifiedType::hashValue() const {
  size_t hash = coda::runtime::Object::hashValue();
  coda::runtime::hash_combine(hash, coda::runtime::hash(_elementType));
  coda::runtime::hash_combine(hash, coda::runtime::hash(_const));
  coda::runtime::hash_combine(hash, coda::runtime::hash(_shared));
  return hash;
}

void ModifiedType::freezeImpl() {
  if (_elementType->isMutable()) {
    _elementType->freeze();
  }
}

void ModifiedType::beginWrite(coda::io::Encoder* encoder) const {
  encoder->writeBeginSubtype("ModifiedType", coda::descriptors::TYPE_KIND_MODIFIED);
}

void ModifiedType::endWrite(coda::io::Encoder* encoder) const {
  if (hasElementType()) {
    encoder->writeFieldHeader("elementType", 1);
    encoder->writeSharedStruct(_elementType);
  }
  if (hasConst()) {
    encoder->writeFieldHeader("const", 2);
    encoder->writeBoolean(_const);
  }
  if (hasShared()) {
    encoder->writeFieldHeader("shared", 3);
    encoder->writeBoolean(_shared);
  }
  encoder->writeEndSubtype();
}

// ============================================================================
// DeclType
// ============================================================================

coda::descriptors::FieldDescriptor DeclType::Field_file(
    "file", 2,
    coda::types::Modified<FileDescriptor, false, true>::DESCRIPTOR,
    _options0,
    CODA_OFFSET_OF(DeclType, _file));
coda::descriptors::FieldDescriptor DeclType::Field_enclosingType(
    "enclosingType", 3,
    coda::types::Modified<StructType, false, true>::DESCRIPTOR,
    _options0,
    CODA_OFFSET_OF(DeclType, _enclosingType));
coda::descriptors::FieldDescriptor DeclType::Field_name(
    "name", 4,
    coda::types::String::DESCRIPTOR,
    coda::descriptors::FieldOptions::DEFAULT_INSTANCE,
    CODA_OFFSET_OF(DeclType, _name));
coda::descriptors::FieldDescriptor DeclType::Field_sourceLine(
    "sourceLine", 5,
    coda::types::Integer32::DESCRIPTOR,
    coda::descriptors::FieldOptions::DEFAULT_INSTANCE,
    CODA_OFFSET_OF(DeclType, _sourceLine));

coda::descriptors::FieldDescriptor* DeclType::Fields[] = {
  &DeclType::Field_file,
  &DeclType::Field_enclosingType,
  &DeclType::Field_name,
  &DeclType::Field_sourceLine,
};

const uint32_t DeclType::TYPE_ID = 41;

coda::descriptors::StructDescriptor DeclType::DESCRIPTOR(
  "DeclType",
  41,
  &DeclType::DEFAULT_INSTANCE,
  FILE,
  NULL,
  &Type::DESCRIPTOR,
  _options4,
  coda::descriptors::StaticArrayRef<coda::descriptors::StructDescriptor*>(),
  coda::descriptors::StaticArrayRef<coda::descriptors::EnumDescriptor*>(),
  DeclType::Fields,
  &coda::descriptors::StaticObjectBuilder<DeclType>::create
);

DeclType DeclType::DEFAULT_INSTANCE;

bool DeclType::equals(const coda::runtime::Object* other) const {
  return Type::equals(other) &&
        _file == ((DeclType*) other)->_file &&
        _enclosingType == ((DeclType*) other)->_enclosingType &&
        _name == ((DeclType*) other)->_name &&
        _sourceLine == ((DeclType*) other)->_sourceLine;
}

size_t DeclType::hashValue() const {
  size_t hash = coda::runtime::Object::hashValue();
  coda::runtime::hash_combine(hash, coda::runtime::hash(_file));
  coda::runtime::hash_combine(hash, coda::runtime::hash(_enclosingType));
  coda::runtime::hash_combine(hash, coda::runtime::hash(_name));
  coda::runtime::hash_combine(hash, coda::runtime::hash(_sourceLine));
  return hash;
}

void DeclType::freezeImpl() {
  if (_file && _file->isMutable()) {
    _file->freeze();
  }
  if (_enclosingType && _enclosingType->isMutable()) {
    _enclosingType->freeze();
  }
}

void DeclType::beginWrite(coda::io::Encoder* encoder) const {
  encoder->writeBeginSubtype("DeclType", coda::descriptors::TYPE_KIND_DECL);
}

void DeclType::endWrite(coda::io::Encoder* encoder) const {
  if (hasFile()) {
    encoder->writeFieldHeader("file", 2);
    encoder->writeSharedStruct(_file);
  }
  if (hasEnclosingType()) {
    encoder->writeFieldHeader("enclosingType", 3);
    encoder->writeSharedStruct(_enclosingType);
  }
  if (hasName()) {
    encoder->writeFieldHeader("name", 4);
    encoder->writeString(_name);
  }
  if (hasSourceLine()) {
    encoder->writeFieldHeader("sourceLine", 5);
    encoder->writeInteger(_sourceLine);
  }
  encoder->writeEndSubtype();
}

// ============================================================================
// StructType
// ============================================================================

coda::descriptors::FieldDescriptor StructType::Field_options(
    "options", 1,
    coda::types::Modified<StructOptions, false, true>::DESCRIPTOR,
    coda::descriptors::FieldOptions::DEFAULT_INSTANCE,
    CODA_OFFSET_OF(StructType, _options));
coda::descriptors::FieldDescriptor StructType::Field_baseType(
    "baseType", 3,
    coda::types::Modified<StructType, false, true>::DESCRIPTOR,
    _options0,
    CODA_OFFSET_OF(StructType, _baseType));
coda::descriptors::FieldDescriptor StructType::Field_typeId(
    "typeId", 4,
    coda::types::Integer32::DESCRIPTOR,
    coda::descriptors::FieldOptions::DEFAULT_INSTANCE,
    CODA_OFFSET_OF(StructType, _typeId));
coda::descriptors::FieldDescriptor StructType::Field_fields(
    "fields", 5,
    coda::types::List<StructType::Field>::DESCRIPTOR,
    coda::descriptors::FieldOptions::DEFAULT_INSTANCE,
    CODA_OFFSET_OF(StructType, _fields));
coda::descriptors::FieldDescriptor StructType::Field_structs(
    "structs", 6,
    coda::types::List<coda::types::Modified<StructType, false, true> >::DESCRIPTOR,
    coda::descriptors::FieldOptions::DEFAULT_INSTANCE,
    CODA_OFFSET_OF(StructType, _structs));
coda::descriptors::FieldDescriptor StructType::Field_enums(
    "enums", 7,
    coda::types::List<coda::types::Modified<EnumType, false, true> >::DESCRIPTOR,
    coda::descriptors::FieldOptions::DEFAULT_INSTANCE,
    CODA_OFFSET_OF(StructType, _enums));
coda::descriptors::FieldDescriptor StructType::Field_extensions(
    "extensions", 8,
    coda::types::List<ExtensionField>::DESCRIPTOR,
    coda::descriptors::FieldOptions::DEFAULT_INSTANCE,
    CODA_OFFSET_OF(StructType, _extensions));
coda::descriptors::FieldDescriptor StructType::Field_minExtension(
    "minExtension", 9,
    coda::types::Integer32::DESCRIPTOR,
    coda::descriptors::FieldOptions::DEFAULT_INSTANCE,
    CODA_OFFSET_OF(StructType, _minExtension));
coda::descriptors::FieldDescriptor StructType::Field_maxExtension(
    "maxExtension", 10,
    coda::types::Integer32::DESCRIPTOR,
    coda::descriptors::FieldOptions::DEFAULT_INSTANCE,
    CODA_OFFSET_OF(StructType, _maxExtension));

static coda::descriptors::StructDescriptor* StructType_Structs[] = {
  &StructType::Field::DESCRIPTOR,
  &StructType::Param::DESCRIPTOR,
  &StructType::Method::DESCRIPTOR,
};

coda::descriptors::FieldDescriptor* StructType::Fields[] = {
  &StructType::Field_options,
  &StructType::Field_baseType,
  &StructType::Field_typeId,
  &StructType::Field_fields,
  &StructType::Field_structs,
  &StructType::Field_enums,
  &StructType::Field_extensions,
  &StructType::Field_minExtension,
  &StructType::Field_maxExtension,
};

const uint32_t StructType::TYPE_ID = 30;

coda::descriptors::StructDescriptor StructType::DESCRIPTOR(
  "StructType",
  30,
  &StructType::DEFAULT_INSTANCE,
  FILE,
  NULL,
  &DeclType::DESCRIPTOR,
  coda::descriptors::StructOptions::DEFAULT_INSTANCE,
  StructType_Structs,
  coda::descriptors::StaticArrayRef<coda::descriptors::EnumDescriptor*>(),
  StructType::Fields,
  &coda::descriptors::StaticObjectBuilder<StructType>::create
);

StructType StructType::DEFAULT_INSTANCE;

// ============================================================================
// Field
// ============================================================================

coda::descriptors::FieldDescriptor StructType::Field::Field_name(
    "name", 1,
    coda::types::String::DESCRIPTOR,
    coda::descriptors::FieldOptions::DEFAULT_INSTANCE,
    CODA_OFFSET_OF(StructType::Field, _name));
coda::descriptors::FieldDescriptor StructType::Field::Field_type(
    "type", 2,
    coda::types::Modified<Type, false, true>::DESCRIPTOR,
    coda::descriptors::FieldOptions::DEFAULT_INSTANCE,
    CODA_OFFSET_OF(StructType::Field, _type));
coda::descriptors::FieldDescriptor StructType::Field::Field_id(
    "id", 3,
    coda::types::Integer32::DESCRIPTOR,
    coda::descriptors::FieldOptions::DEFAULT_INSTANCE,
    CODA_OFFSET_OF(StructType::Field, _id));
coda::descriptors::FieldDescriptor StructType::Field::Field_options(
    "options", 4,
    coda::types::Modified<FieldOptions, false, true>::DESCRIPTOR,
    coda::descriptors::FieldOptions::DEFAULT_INSTANCE,
    CODA_OFFSET_OF(StructType::Field, _options));

coda::descriptors::FieldDescriptor* StructType::Field::Fields[] = {
  &StructType::Field::Field_name,
  &StructType::Field::Field_type,
  &StructType::Field::Field_id,
  &StructType::Field::Field_options,
};

const uint32_t StructType::Field::TYPE_ID = 0;

coda::descriptors::StructDescriptor StructType::Field::DESCRIPTOR(
  "StructType::Field",
  0,
  &StructType::Field::DEFAULT_INSTANCE,
  FILE,
  &StructType::DESCRIPTOR,
  NULL,
  coda::descriptors::StructOptions::DEFAULT_INSTANCE,
  coda::descriptors::StaticArrayRef<coda::descriptors::StructDescriptor*>(),
  coda::descriptors::StaticArrayRef<coda::descriptors::EnumDescriptor*>(),
  Field::Fields,
  &coda::descriptors::StaticObjectBuilder<StructType::Field>::create
);

StructType::Field StructType::Field::DEFAULT_INSTANCE;

StructType::Field::Field()
  : _type(NULL)
  , _id(0)
  , _options(NULL)
{
}

bool StructType::Field::equals(const coda::runtime::Object* other) const {
  return other != NULL && descriptor() == other->descriptor() &&
        _name == ((Field*) other)->_name &&
        _type == ((Field*) other)->_type &&
        _id == ((Field*) other)->_id &&
        _options == ((Field*) other)->_options;
}

size_t StructType::Field::hashValue() const {
  size_t hash = coda::runtime::Object::hashValue();
  coda::runtime::hash_combine(hash, coda::runtime::hash(_name));
  coda::runtime::hash_combine(hash, coda::runtime::hash(_type));
  coda::runtime::hash_combine(hash, coda::runtime::hash(_id));
  coda::runtime::hash_combine(hash, coda::runtime::hash(_options));
  return hash;
}

void StructType::Field::freezeImpl() {
  if (_type->isMutable()) {
    _type->freeze();
  }
  if (_options->isMutable()) {
    _options->freeze();
  }
}

void StructType::Field::endWrite(coda::io::Encoder* encoder) const {
  if (hasName()) {
    encoder->writeFieldHeader("name", 1);
    encoder->writeString(_name);
  }
  if (hasType()) {
    encoder->writeFieldHeader("type", 2);
    encoder->writeSharedStruct(_type);
  }
  if (hasId()) {
    encoder->writeFieldHeader("id", 3);
    encoder->writeInteger(_id);
  }
  if (hasOptions()) {
    encoder->writeFieldHeader("options", 4);
    encoder->writeSharedStruct(_options);
  }
}

// ============================================================================
// Param
// ============================================================================

coda::descriptors::FieldDescriptor StructType::Param::Field_name(
    "name", 1,
    coda::types::String::DESCRIPTOR,
    coda::descriptors::FieldOptions::DEFAULT_INSTANCE,
    CODA_OFFSET_OF(StructType::Param, _name));
coda::descriptors::FieldDescriptor StructType::Param::Field_type(
    "type", 2,
    coda::types::Modified<Type, false, true>::DESCRIPTOR,
    coda::descriptors::FieldOptions::DEFAULT_INSTANCE,
    CODA_OFFSET_OF(StructType::Param, _type));

coda::descriptors::FieldDescriptor* StructType::Param::Fields[] = {
  &StructType::Param::Field_name,
  &StructType::Param::Field_type,
};

const uint32_t StructType::Param::TYPE_ID = 0;

coda::descriptors::StructDescriptor StructType::Param::DESCRIPTOR(
  "StructType::Param",
  0,
  &StructType::Param::DEFAULT_INSTANCE,
  FILE,
  &StructType::DESCRIPTOR,
  NULL,
  coda::descriptors::StructOptions::DEFAULT_INSTANCE,
  coda::descriptors::StaticArrayRef<coda::descriptors::StructDescriptor*>(),
  coda::descriptors::StaticArrayRef<coda::descriptors::EnumDescriptor*>(),
  Param::Fields,
  &coda::descriptors::StaticObjectBuilder<StructType::Param>::create
);

StructType::Param StructType::Param::DEFAULT_INSTANCE;

StructType::Param::Param()
  : _type(NULL)
{
}

bool StructType::Param::equals(const coda::runtime::Object* other) const {
  return other != NULL && descriptor() == other->descriptor() &&
        _name == ((Param*) other)->_name &&
        _type == ((Param*) other)->_type;
}

size_t StructType::Param::hashValue() const {
  size_t hash = coda::runtime::Object::hashValue();
  coda::runtime::hash_combine(hash, coda::runtime::hash(_name));
  coda::runtime::hash_combine(hash, coda::runtime::hash(_type));
  return hash;
}

void StructType::Param::freezeImpl() {
  if (_type->isMutable()) {
    _type->freeze();
  }
}

void StructType::Param::endWrite(coda::io::Encoder* encoder) const {
  if (hasName()) {
    encoder->writeFieldHeader("name", 1);
    encoder->writeString(_name);
  }
  if (hasType()) {
    encoder->writeFieldHeader("type", 2);
    encoder->writeSharedStruct(_type);
  }
}

// ============================================================================
// Method
// ============================================================================

coda::descriptors::FieldDescriptor StructType::Method::Field_name(
    "name", 1,
    coda::types::String::DESCRIPTOR,
    coda::descriptors::FieldOptions::DEFAULT_INSTANCE,
    CODA_OFFSET_OF(StructType::Method, _name));
coda::descriptors::FieldDescriptor StructType::Method::Field_params(
    "params", 2,
    coda::types::List<StructType::Param>::DESCRIPTOR,
    coda::descriptors::FieldOptions::DEFAULT_INSTANCE,
    CODA_OFFSET_OF(StructType::Method, _params));
coda::descriptors::FieldDescriptor StructType::Method::Field_returnType(
    "returnType", 3,
    coda::types::Modified<Type, false, true>::DESCRIPTOR,
    coda::descriptors::FieldOptions::DEFAULT_INSTANCE,
    CODA_OFFSET_OF(StructType::Method, _returnType));
coda::descriptors::FieldDescriptor StructType::Method::Field_id(
    "id", 4,
    coda::types::Integer32::DESCRIPTOR,
    coda::descriptors::FieldOptions::DEFAULT_INSTANCE,
    CODA_OFFSET_OF(StructType::Method, _id));
coda::descriptors::FieldDescriptor StructType::Method::Field_options(
    "options", 5,
    coda::types::Modified<MethodOptions, false, true>::DESCRIPTOR,
    coda::descriptors::FieldOptions::DEFAULT_INSTANCE,
    CODA_OFFSET_OF(StructType::Method, _options));

coda::descriptors::FieldDescriptor* StructType::Method::Fields[] = {
  &StructType::Method::Field_name,
  &StructType::Method::Field_params,
  &StructType::Method::Field_returnType,
  &StructType::Method::Field_id,
  &StructType::Method::Field_options,
};

const uint32_t StructType::Method::TYPE_ID = 0;

coda::descriptors::StructDescriptor StructType::Method::DESCRIPTOR(
  "StructType::Method",
  0,
  &StructType::Method::DEFAULT_INSTANCE,
  FILE,
  &StructType::DESCRIPTOR,
  NULL,
  coda::descriptors::StructOptions::DEFAULT_INSTANCE,
  coda::descriptors::StaticArrayRef<coda::descriptors::StructDescriptor*>(),
  coda::descriptors::StaticArrayRef<coda::descriptors::EnumDescriptor*>(),
  Method::Fields,
  &coda::descriptors::StaticObjectBuilder<StructType::Method>::create
);

StructType::Method StructType::Method::DEFAULT_INSTANCE;

StructType::Method::Method()
  : _returnType(NULL)
  , _id(0)
  , _options(NULL)
{
}

bool StructType::Method::equals(const coda::runtime::Object* other) const {
  return other != NULL && descriptor() == other->descriptor() &&
        _name == ((Method*) other)->_name &&
        _params == ((Method*) other)->_params &&
        _returnType == ((Method*) other)->_returnType &&
        _id == ((Method*) other)->_id &&
        _options == ((Method*) other)->_options;
}

size_t StructType::Method::hashValue() const {
  size_t hash = coda::runtime::Object::hashValue();
  coda::runtime::hash_combine(hash, coda::runtime::hash(_name));
  coda::runtime::hash_combine(hash, coda::runtime::hash(_params));
  coda::runtime::hash_combine(hash, coda::runtime::hash(_returnType));
  coda::runtime::hash_combine(hash, coda::runtime::hash(_id));
  coda::runtime::hash_combine(hash, coda::runtime::hash(_options));
  return hash;
}

void StructType::Method::freezeImpl() {
  for (std::vector<StructType::Param*>::const_iterator it = _params.begin(), itEnd = _params.end(); it != itEnd; ++it) {
    if ((*it)->isMutable()) {
      (*it)->freeze();
    }
  }
  if (_returnType->isMutable()) {
    _returnType->freeze();
  }
  if (_options->isMutable()) {
    _options->freeze();
  }
}

void StructType::Method::endWrite(coda::io::Encoder* encoder) const {
  if (hasName()) {
    encoder->writeFieldHeader("name", 1);
    encoder->writeString(_name);
  }
  if (!_params.empty()) {
    encoder->writeFieldHeader("params", 2);
    encoder->writeBeginList(coda::descriptors::TYPE_KIND_STRUCT, _params.size());
    for (std::vector<StructType::Param*>::const_iterator it = _params.begin(), itEnd = _params.end(); it != itEnd; ++it) {
      encoder->writeSharedStruct(*it);
    }
    encoder->writeEndList();
  }
  if (hasReturnType()) {
    encoder->writeFieldHeader("returnType", 3);
    encoder->writeSharedStruct(_returnType);
  }
  if (hasId()) {
    encoder->writeFieldHeader("id", 4);
    encoder->writeInteger(_id);
  }
  if (hasOptions()) {
    encoder->writeFieldHeader("options", 5);
    encoder->writeSharedStruct(_options);
  }
}

StructType::StructType()
  : _options(NULL)
  , _baseType(NULL)
  , _typeId(0)
  , _minExtension(0)
  , _maxExtension(0)
{
}

bool StructType::equals(const coda::runtime::Object* other) const {
  return DeclType::equals(other) &&
        _options == ((StructType*) other)->_options &&
        _baseType == ((StructType*) other)->_baseType &&
        _typeId == ((StructType*) other)->_typeId &&
        _fields == ((StructType*) other)->_fields &&
        _structs == ((StructType*) other)->_structs &&
        _enums == ((StructType*) other)->_enums &&
        _extensions == ((StructType*) other)->_extensions &&
        _minExtension == ((StructType*) other)->_minExtension &&
        _maxExtension == ((StructType*) other)->_maxExtension;
}

size_t StructType::hashValue() const {
  size_t hash = DeclType::hashValue();
  coda::runtime::hash_combine(hash, coda::runtime::hash(_options));
  coda::runtime::hash_combine(hash, coda::runtime::hash(_baseType));
  coda::runtime::hash_combine(hash, coda::runtime::hash(_typeId));
  coda::runtime::hash_combine(hash, coda::runtime::hash(_fields));
  coda::runtime::hash_combine(hash, coda::runtime::hash(_structs));
  coda::runtime::hash_combine(hash, coda::runtime::hash(_enums));
  coda::runtime::hash_combine(hash, coda::runtime::hash(_extensions));
  coda::runtime::hash_combine(hash, coda::runtime::hash(_minExtension));
  coda::runtime::hash_combine(hash, coda::runtime::hash(_maxExtension));
  return hash;
}

void StructType::freezeImpl() {
  DeclType::freezeImpl();
  if (_options->isMutable()) {
    _options->freeze();
  }
  if (_baseType && _baseType->isMutable()) {
    _baseType->freeze();
  }
  for (std::vector<StructType::Field*>::const_iterator it = _fields.begin(), itEnd = _fields.end(); it != itEnd; ++it) {
    if ((*it)->isMutable()) {
      (*it)->freeze();
    }
  }
  for (std::vector<StructType*>::const_iterator it = _structs.begin(), itEnd = _structs.end(); it != itEnd; ++it) {
    if ((*it)->isMutable()) {
      (*it)->freeze();
    }
  }
  for (std::vector<EnumType*>::const_iterator it = _enums.begin(), itEnd = _enums.end(); it != itEnd; ++it) {
    if ((*it)->isMutable()) {
      (*it)->freeze();
    }
  }
  for (std::vector<ExtensionField*>::const_iterator it = _extensions.begin(), itEnd = _extensions.end(); it != itEnd; ++it) {
    if ((*it)->isMutable()) {
      (*it)->freeze();
    }
  }
}

void StructType::beginWrite(coda::io::Encoder* encoder) const {
  DeclType::beginWrite(encoder);
  encoder->writeBeginSubtype("StructType", coda::descriptors::TYPE_KIND_STRUCT);
}

void StructType::endWrite(coda::io::Encoder* encoder) const {
  if (hasOptions()) {
    encoder->writeFieldHeader("options", 1);
    encoder->writeSharedStruct(_options);
  }
  if (hasBaseType()) {
    encoder->writeFieldHeader("baseType", 3);
    encoder->writeSharedStruct(_baseType);
  }
  if (hasTypeId()) {
    encoder->writeFieldHeader("typeId", 4);
    encoder->writeInteger(_typeId);
  }
  if (!_fields.empty()) {
    encoder->writeFieldHeader("fields", 5);
    encoder->writeBeginList(coda::descriptors::TYPE_KIND_STRUCT, _fields.size());
    for (std::vector<StructType::Field*>::const_iterator it = _fields.begin(), itEnd = _fields.end(); it != itEnd; ++it) {
      encoder->writeSharedStruct(*it);
    }
    encoder->writeEndList();
  }
  if (!_structs.empty()) {
    encoder->writeFieldHeader("structs", 6);
    encoder->writeBeginList(coda::descriptors::TYPE_KIND_MODIFIED, _structs.size());
    for (std::vector<StructType*>::const_iterator it = _structs.begin(), itEnd = _structs.end(); it != itEnd; ++it) {
      encoder->writeSharedStruct(*it);
    }
    encoder->writeEndList();
  }
  if (!_enums.empty()) {
    encoder->writeFieldHeader("enums", 7);
    encoder->writeBeginList(coda::descriptors::TYPE_KIND_MODIFIED, _enums.size());
    for (std::vector<EnumType*>::const_iterator it = _enums.begin(), itEnd = _enums.end(); it != itEnd; ++it) {
      encoder->writeSharedStruct(*it);
    }
    encoder->writeEndList();
  }
  if (!_extensions.empty()) {
    encoder->writeFieldHeader("extensions", 8);
    encoder->writeBeginList(coda::descriptors::TYPE_KIND_STRUCT, _extensions.size());
    for (std::vector<ExtensionField*>::const_iterator it = _extensions.begin(), itEnd = _extensions.end(); it != itEnd; ++it) {
      encoder->writeSharedStruct(*it);
    }
    encoder->writeEndList();
  }
  if (hasMinExtension()) {
    encoder->writeFieldHeader("minExtension", 9);
    encoder->writeInteger(_minExtension);
  }
  if (hasMaxExtension()) {
    encoder->writeFieldHeader("maxExtension", 10);
    encoder->writeInteger(_maxExtension);
  }
  encoder->writeEndSubtype();
  DeclType::endWrite(encoder);
}

// ============================================================================
// EnumType
// ============================================================================

coda::descriptors::FieldDescriptor EnumType::Field_options(
    "options", 1,
    coda::types::Modified<EnumOptions, false, true>::DESCRIPTOR,
    coda::descriptors::FieldOptions::DEFAULT_INSTANCE,
    CODA_OFFSET_OF(EnumType, _options));
coda::descriptors::FieldDescriptor EnumType::Field_values(
    "values", 2,
    coda::types::List<EnumType::Value>::DESCRIPTOR,
    coda::descriptors::FieldOptions::DEFAULT_INSTANCE,
    CODA_OFFSET_OF(EnumType, _values));

static coda::descriptors::StructDescriptor* EnumType_Structs[] = {
  &EnumType::Value::DESCRIPTOR,
};

coda::descriptors::FieldDescriptor* EnumType::Fields[] = {
  &EnumType::Field_options,
  &EnumType::Field_values,
};

const uint32_t EnumType::TYPE_ID = 31;

coda::descriptors::StructDescriptor EnumType::DESCRIPTOR(
  "EnumType",
  31,
  &EnumType::DEFAULT_INSTANCE,
  FILE,
  NULL,
  &DeclType::DESCRIPTOR,
  coda::descriptors::StructOptions::DEFAULT_INSTANCE,
  EnumType_Structs,
  coda::descriptors::StaticArrayRef<coda::descriptors::EnumDescriptor*>(),
  EnumType::Fields,
  &coda::descriptors::StaticObjectBuilder<EnumType>::create
);

EnumType EnumType::DEFAULT_INSTANCE;

// ============================================================================
// Value
// ============================================================================

coda::descriptors::FieldDescriptor EnumType::Value::Field_name(
    "name", 1,
    coda::types::String::DESCRIPTOR,
    coda::descriptors::FieldOptions::DEFAULT_INSTANCE,
    CODA_OFFSET_OF(EnumType::Value, _name));
coda::descriptors::FieldDescriptor EnumType::Value::Field_value(
    "value", 2,
    coda::types::Integer32::DESCRIPTOR,
    coda::descriptors::FieldOptions::DEFAULT_INSTANCE,
    CODA_OFFSET_OF(EnumType::Value, _value));

coda::descriptors::FieldDescriptor* EnumType::Value::Fields[] = {
  &EnumType::Value::Field_name,
  &EnumType::Value::Field_value,
};

const uint32_t EnumType::Value::TYPE_ID = 0;

coda::descriptors::StructDescriptor EnumType::Value::DESCRIPTOR(
  "EnumType::Value",
  0,
  &EnumType::Value::DEFAULT_INSTANCE,
  FILE,
  &EnumType::DESCRIPTOR,
  NULL,
  coda::descriptors::StructOptions::DEFAULT_INSTANCE,
  coda::descriptors::StaticArrayRef<coda::descriptors::StructDescriptor*>(),
  coda::descriptors::StaticArrayRef<coda::descriptors::EnumDescriptor*>(),
  Value::Fields,
  &coda::descriptors::StaticObjectBuilder<EnumType::Value>::create
);

EnumType::Value EnumType::Value::DEFAULT_INSTANCE;

bool EnumType::Value::equals(const coda::runtime::Object* other) const {
  return other != NULL && descriptor() == other->descriptor() &&
        _name == ((Value*) other)->_name &&
        _value == ((Value*) other)->_value;
}

size_t EnumType::Value::hashValue() const {
  size_t hash = coda::runtime::Object::hashValue();
  coda::runtime::hash_combine(hash, coda::runtime::hash(_name));
  coda::runtime::hash_combine(hash, coda::runtime::hash(_value));
  return hash;
}

void EnumType::Value::freezeImpl() {
}

void EnumType::Value::endWrite(coda::io::Encoder* encoder) const {
  if (hasName()) {
    encoder->writeFieldHeader("name", 1);
    encoder->writeString(_name);
  }
  if (hasValue()) {
    encoder->writeFieldHeader("value", 2);
    encoder->writeInteger(_value);
  }
}

EnumType::EnumType()
  : _options(NULL)
{
}

bool EnumType::equals(const coda::runtime::Object* other) const {
  return DeclType::equals(other) &&
        _options == ((EnumType*) other)->_options &&
        _values == ((EnumType*) other)->_values;
}

size_t EnumType::hashValue() const {
  size_t hash = DeclType::hashValue();
  coda::runtime::hash_combine(hash, coda::runtime::hash(_options));
  coda::runtime::hash_combine(hash, coda::runtime::hash(_values));
  return hash;
}

void EnumType::freezeImpl() {
  DeclType::freezeImpl();
  if (_options->isMutable()) {
    _options->freeze();
  }
  for (std::vector<EnumType::Value*>::const_iterator it = _values.begin(), itEnd = _values.end(); it != itEnd; ++it) {
    if ((*it)->isMutable()) {
      (*it)->freeze();
    }
  }
}

void EnumType::beginWrite(coda::io::Encoder* encoder) const {
  DeclType::beginWrite(encoder);
  encoder->writeBeginSubtype("EnumType", coda::descriptors::TYPE_KIND_ENUM);
}

void EnumType::endWrite(coda::io::Encoder* encoder) const {
  if (hasOptions()) {
    encoder->writeFieldHeader("options", 1);
    encoder->writeSharedStruct(_options);
  }
  if (!_values.empty()) {
    encoder->writeFieldHeader("values", 2);
    encoder->writeBeginList(coda::descriptors::TYPE_KIND_STRUCT, _values.size());
    for (std::vector<EnumType::Value*>::const_iterator it = _values.begin(), itEnd = _values.end(); it != itEnd; ++it) {
      encoder->writeSharedStruct(*it);
    }
    encoder->writeEndList();
  }
  encoder->writeEndSubtype();
  DeclType::endWrite(encoder);
}

// ============================================================================
// ExtensionField
// ============================================================================

coda::descriptors::FieldDescriptor ExtensionField::Field_file(
    "file", 1,
    coda::types::Modified<FileDescriptor, false, true>::DESCRIPTOR,
    _options0,
    CODA_OFFSET_OF(ExtensionField, _file));
coda::descriptors::FieldDescriptor ExtensionField::Field_enclosingType(
    "enclosingType", 2,
    StructType::DESCRIPTOR,
    coda::descriptors::FieldOptions::DEFAULT_INSTANCE,
    CODA_OFFSET_OF(ExtensionField, _enclosingType));
coda::descriptors::FieldDescriptor ExtensionField::Field_sourceLine(
    "sourceLine", 3,
    coda::types::Integer32::DESCRIPTOR,
    coda::descriptors::FieldOptions::DEFAULT_INSTANCE,
    CODA_OFFSET_OF(ExtensionField, _sourceLine));
coda::descriptors::FieldDescriptor ExtensionField::Field_extends(
    "extends", 4,
    coda::types::Modified<StructType, false, true>::DESCRIPTOR,
    coda::descriptors::FieldOptions::DEFAULT_INSTANCE,
    CODA_OFFSET_OF(ExtensionField, _extends));
coda::descriptors::FieldDescriptor ExtensionField::Field_name(
    "name", 5,
    coda::types::String::DESCRIPTOR,
    coda::descriptors::FieldOptions::DEFAULT_INSTANCE,
    CODA_OFFSET_OF(ExtensionField, _name));
coda::descriptors::FieldDescriptor ExtensionField::Field_id(
    "id", 6,
    coda::types::Integer32::DESCRIPTOR,
    coda::descriptors::FieldOptions::DEFAULT_INSTANCE,
    CODA_OFFSET_OF(ExtensionField, _id));
coda::descriptors::FieldDescriptor ExtensionField::Field_type(
    "type", 7,
    coda::types::Modified<Type, false, true>::DESCRIPTOR,
    coda::descriptors::FieldOptions::DEFAULT_INSTANCE,
    CODA_OFFSET_OF(ExtensionField, _type));

coda::descriptors::FieldDescriptor* ExtensionField::Fields[] = {
  &ExtensionField::Field_file,
  &ExtensionField::Field_enclosingType,
  &ExtensionField::Field_sourceLine,
  &ExtensionField::Field_extends,
  &ExtensionField::Field_name,
  &ExtensionField::Field_id,
  &ExtensionField::Field_type,
};

const uint32_t ExtensionField::TYPE_ID = 0;

coda::descriptors::StructDescriptor ExtensionField::DESCRIPTOR(
  "ExtensionField",
  0,
  &ExtensionField::DEFAULT_INSTANCE,
  FILE,
  NULL,
  NULL,
  coda::descriptors::StructOptions::DEFAULT_INSTANCE,
  coda::descriptors::StaticArrayRef<coda::descriptors::StructDescriptor*>(),
  coda::descriptors::StaticArrayRef<coda::descriptors::EnumDescriptor*>(),
  ExtensionField::Fields,
  &coda::descriptors::StaticObjectBuilder<ExtensionField>::create
);

ExtensionField ExtensionField::DEFAULT_INSTANCE;

ExtensionField::ExtensionField()
  : _file(NULL)
  , _enclosingType(NULL)
  , _sourceLine(0)
  , _extends(NULL)
  , _id(0)
  , _type(NULL)
{
}

bool ExtensionField::equals(const coda::runtime::Object* other) const {
  return other != NULL && descriptor() == other->descriptor() &&
        _file == ((ExtensionField*) other)->_file &&
        _enclosingType == ((ExtensionField*) other)->_enclosingType &&
        _sourceLine == ((ExtensionField*) other)->_sourceLine &&
        _extends == ((ExtensionField*) other)->_extends &&
        _name == ((ExtensionField*) other)->_name &&
        _id == ((ExtensionField*) other)->_id &&
        _type == ((ExtensionField*) other)->_type;
}

size_t ExtensionField::hashValue() const {
  size_t hash = coda::runtime::Object::hashValue();
  coda::runtime::hash_combine(hash, coda::runtime::hash(_file));
  coda::runtime::hash_combine(hash, coda::runtime::hash(_enclosingType));
  coda::runtime::hash_combine(hash, coda::runtime::hash(_sourceLine));
  coda::runtime::hash_combine(hash, coda::runtime::hash(_extends));
  coda::runtime::hash_combine(hash, coda::runtime::hash(_name));
  coda::runtime::hash_combine(hash, coda::runtime::hash(_id));
  coda::runtime::hash_combine(hash, coda::runtime::hash(_type));
  return hash;
}

void ExtensionField::freezeImpl() {
  if (_file && _file->isMutable()) {
    _file->freeze();
  }
  if (_enclosingType->isMutable()) {
    _enclosingType->freeze();
  }
  if (_extends->isMutable()) {
    _extends->freeze();
  }
  if (_type->isMutable()) {
    _type->freeze();
  }
}

void ExtensionField::endWrite(coda::io::Encoder* encoder) const {
  if (hasFile()) {
    encoder->writeFieldHeader("file", 1);
    encoder->writeSharedStruct(_file);
  }
  if (hasEnclosingType()) {
    encoder->writeFieldHeader("enclosingType", 2);
    encoder->writeSharedStruct(_enclosingType);
  }
  if (hasSourceLine()) {
    encoder->writeFieldHeader("sourceLine", 3);
    encoder->writeInteger(_sourceLine);
  }
  if (hasExtends()) {
    encoder->writeFieldHeader("extends", 4);
    encoder->writeSharedStruct(_extends);
  }
  if (hasName()) {
    encoder->writeFieldHeader("name", 5);
    encoder->writeString(_name);
  }
  if (hasId()) {
    encoder->writeFieldHeader("id", 6);
    encoder->writeInteger(_id);
  }
  if (hasType()) {
    encoder->writeFieldHeader("type", 7);
    encoder->writeSharedStruct(_type);
  }
}

// ============================================================================
// FileDescriptor
// ============================================================================

coda::descriptors::FieldDescriptor FileDescriptor::Field_name(
    "name", 1,
    coda::types::String::DESCRIPTOR,
    coda::descriptors::FieldOptions::DEFAULT_INSTANCE,
    CODA_OFFSET_OF(FileDescriptor, _name));
coda::descriptors::FieldDescriptor FileDescriptor::Field_directory(
    "directory", 2,
    coda::types::String::DESCRIPTOR,
    coda::descriptors::FieldOptions::DEFAULT_INSTANCE,
    CODA_OFFSET_OF(FileDescriptor, _directory));
coda::descriptors::FieldDescriptor FileDescriptor::Field_package(
    "package", 3,
    coda::types::String::DESCRIPTOR,
    coda::descriptors::FieldOptions::DEFAULT_INSTANCE,
    CODA_OFFSET_OF(FileDescriptor, _package));
coda::descriptors::FieldDescriptor FileDescriptor::Field_options(
    "options", 4,
    FileOptions::DESCRIPTOR,
    coda::descriptors::FieldOptions::DEFAULT_INSTANCE,
    CODA_OFFSET_OF(FileDescriptor, _options));
coda::descriptors::FieldDescriptor FileDescriptor::Field_structs(
    "structs", 5,
    coda::types::List<coda::types::Modified<StructType, false, true> >::DESCRIPTOR,
    coda::descriptors::FieldOptions::DEFAULT_INSTANCE,
    CODA_OFFSET_OF(FileDescriptor, _structs));
coda::descriptors::FieldDescriptor FileDescriptor::Field_enums(
    "enums", 6,
    coda::types::List<coda::types::Modified<EnumType, false, true> >::DESCRIPTOR,
    coda::descriptors::FieldOptions::DEFAULT_INSTANCE,
    CODA_OFFSET_OF(FileDescriptor, _enums));
coda::descriptors::FieldDescriptor FileDescriptor::Field_extensions(
    "extensions", 7,
    coda::types::List<coda::types::Modified<ExtensionField, false, true> >::DESCRIPTOR,
    coda::descriptors::FieldOptions::DEFAULT_INSTANCE,
    CODA_OFFSET_OF(FileDescriptor, _extensions));
coda::descriptors::FieldDescriptor FileDescriptor::Field_imports(
    "imports", 8,
    coda::types::List<FileDescriptor::Import>::DESCRIPTOR,
    coda::descriptors::FieldOptions::DEFAULT_INSTANCE,
    CODA_OFFSET_OF(FileDescriptor, _imports));

static coda::descriptors::StructDescriptor* FileDescriptor_Structs[] = {
  &FileDescriptor::Import::DESCRIPTOR,
};

coda::descriptors::FieldDescriptor* FileDescriptor::Fields[] = {
  &FileDescriptor::Field_name,
  &FileDescriptor::Field_directory,
  &FileDescriptor::Field_package,
  &FileDescriptor::Field_options,
  &FileDescriptor::Field_structs,
  &FileDescriptor::Field_enums,
  &FileDescriptor::Field_extensions,
  &FileDescriptor::Field_imports,
};

const uint32_t FileDescriptor::TYPE_ID = 0;

coda::descriptors::StructDescriptor FileDescriptor::DESCRIPTOR(
  "FileDescriptor",
  0,
  &FileDescriptor::DEFAULT_INSTANCE,
  FILE,
  NULL,
  NULL,
  coda::descriptors::StructOptions::DEFAULT_INSTANCE,
  FileDescriptor_Structs,
  coda::descriptors::StaticArrayRef<coda::descriptors::EnumDescriptor*>(),
  FileDescriptor::Fields,
  &coda::descriptors::StaticObjectBuilder<FileDescriptor>::create
);

FileDescriptor FileDescriptor::DEFAULT_INSTANCE;

// ============================================================================
// Import
// ============================================================================

coda::descriptors::FieldDescriptor FileDescriptor::Import::Field_path(
    "path", 1,
    coda::types::String::DESCRIPTOR,
    coda::descriptors::FieldOptions::DEFAULT_INSTANCE,
    CODA_OFFSET_OF(FileDescriptor::Import, _path));
coda::descriptors::FieldDescriptor FileDescriptor::Import::Field_package(
    "package", 2,
    coda::types::Map<coda::types::String, coda::types::String >::DESCRIPTOR,
    coda::descriptors::FieldOptions::DEFAULT_INSTANCE,
    CODA_OFFSET_OF(FileDescriptor::Import, _package));

coda::descriptors::FieldDescriptor* FileDescriptor::Import::Fields[] = {
  &FileDescriptor::Import::Field_path,
  &FileDescriptor::Import::Field_package,
};

const uint32_t FileDescriptor::Import::TYPE_ID = 0;

coda::descriptors::StructDescriptor FileDescriptor::Import::DESCRIPTOR(
  "FileDescriptor::Import",
  0,
  &FileDescriptor::Import::DEFAULT_INSTANCE,
  FILE,
  &FileDescriptor::DESCRIPTOR,
  NULL,
  coda::descriptors::StructOptions::DEFAULT_INSTANCE,
  coda::descriptors::StaticArrayRef<coda::descriptors::StructDescriptor*>(),
  coda::descriptors::StaticArrayRef<coda::descriptors::EnumDescriptor*>(),
  Import::Fields,
  &coda::descriptors::StaticObjectBuilder<FileDescriptor::Import>::create
);

FileDescriptor::Import FileDescriptor::Import::DEFAULT_INSTANCE;

bool FileDescriptor::Import::equals(const coda::runtime::Object* other) const {
  return other != NULL && descriptor() == other->descriptor() &&
        _path == ((Import*) other)->_path &&
        _package == ((Import*) other)->_package;
}

size_t FileDescriptor::Import::hashValue() const {
  size_t hash = coda::runtime::Object::hashValue();
  coda::runtime::hash_combine(hash, coda::runtime::hash(_path));
  coda::runtime::hash_combine(hash, coda::runtime::hash(_package));
  return hash;
}

void FileDescriptor::Import::freezeImpl() {
}

void FileDescriptor::Import::endWrite(coda::io::Encoder* encoder) const {
  if (hasPath()) {
    encoder->writeFieldHeader("path", 1);
    encoder->writeString(_path);
  }
  if (!_package.empty()) {
    encoder->writeFieldHeader("package", 2);
    encoder->writeBeginMap(coda::descriptors::TYPE_KIND_STRING, coda::descriptors::TYPE_KIND_STRING, _package.size());
    for (std::unordered_map<std::string, std::string >::const_iterator it = _package.begin(), itEnd = _package.end(); it != itEnd; ++it) {
      encoder->writeString(it->first);
      encoder->writeString(it->second);
    }
    encoder->writeEndMap();
  }
}

FileDescriptor::FileDescriptor()
  : _options(NULL)
{
}

bool FileDescriptor::equals(const coda::runtime::Object* other) const {
  return other != NULL && descriptor() == other->descriptor() &&
        _name == ((FileDescriptor*) other)->_name &&
        _directory == ((FileDescriptor*) other)->_directory &&
        _package == ((FileDescriptor*) other)->_package &&
        _options == ((FileDescriptor*) other)->_options &&
        _structs == ((FileDescriptor*) other)->_structs &&
        _enums == ((FileDescriptor*) other)->_enums &&
        _extensions == ((FileDescriptor*) other)->_extensions &&
        _imports == ((FileDescriptor*) other)->_imports;
}

size_t FileDescriptor::hashValue() const {
  size_t hash = coda::runtime::Object::hashValue();
  coda::runtime::hash_combine(hash, coda::runtime::hash(_name));
  coda::runtime::hash_combine(hash, coda::runtime::hash(_directory));
  coda::runtime::hash_combine(hash, coda::runtime::hash(_package));
  coda::runtime::hash_combine(hash, coda::runtime::hash(_options));
  coda::runtime::hash_combine(hash, coda::runtime::hash(_structs));
  coda::runtime::hash_combine(hash, coda::runtime::hash(_enums));
  coda::runtime::hash_combine(hash, coda::runtime::hash(_extensions));
  coda::runtime::hash_combine(hash, coda::runtime::hash(_imports));
  return hash;
}

void FileDescriptor::freezeImpl() {
  if (_options->isMutable()) {
    _options->freeze();
  }
  for (std::vector<StructType*>::const_iterator it = _structs.begin(), itEnd = _structs.end(); it != itEnd; ++it) {
    if ((*it)->isMutable()) {
      (*it)->freeze();
    }
  }
  for (std::vector<EnumType*>::const_iterator it = _enums.begin(), itEnd = _enums.end(); it != itEnd; ++it) {
    if ((*it)->isMutable()) {
      (*it)->freeze();
    }
  }
  for (std::vector<ExtensionField*>::const_iterator it = _extensions.begin(), itEnd = _extensions.end(); it != itEnd; ++it) {
    if ((*it)->isMutable()) {
      (*it)->freeze();
    }
  }
  for (std::vector<FileDescriptor::Import*>::const_iterator it = _imports.begin(), itEnd = _imports.end(); it != itEnd; ++it) {
    if ((*it)->isMutable()) {
      (*it)->freeze();
    }
  }
}

void FileDescriptor::endWrite(coda::io::Encoder* encoder) const {
  if (hasName()) {
    encoder->writeFieldHeader("name", 1);
    encoder->writeString(_name);
  }
  if (hasDirectory()) {
    encoder->writeFieldHeader("directory", 2);
    encoder->writeString(_directory);
  }
  if (hasPackage()) {
    encoder->writeFieldHeader("package", 3);
    encoder->writeString(_package);
  }
  if (hasOptions()) {
    encoder->writeFieldHeader("options", 4);
    encoder->writeSharedStruct(_options);
  }
  if (!_structs.empty()) {
    encoder->writeFieldHeader("structs", 5);
    encoder->writeBeginList(coda::descriptors::TYPE_KIND_MODIFIED, _structs.size());
    for (std::vector<StructType*>::const_iterator it = _structs.begin(), itEnd = _structs.end(); it != itEnd; ++it) {
      encoder->writeSharedStruct(*it);
    }
    encoder->writeEndList();
  }
  if (!_enums.empty()) {
    encoder->writeFieldHeader("enums", 6);
    encoder->writeBeginList(coda::descriptors::TYPE_KIND_MODIFIED, _enums.size());
    for (std::vector<EnumType*>::const_iterator it = _enums.begin(), itEnd = _enums.end(); it != itEnd; ++it) {
      encoder->writeSharedStruct(*it);
    }
    encoder->writeEndList();
  }
  if (!_extensions.empty()) {
    encoder->writeFieldHeader("extensions", 7);
    encoder->writeBeginList(coda::descriptors::TYPE_KIND_MODIFIED, _extensions.size());
    for (std::vector<ExtensionField*>::const_iterator it = _extensions.begin(), itEnd = _extensions.end(); it != itEnd; ++it) {
      encoder->writeSharedStruct(*it);
    }
    encoder->writeEndList();
  }
  if (!_imports.empty()) {
    encoder->writeFieldHeader("imports", 8);
    encoder->writeBeginList(coda::descriptors::TYPE_KIND_STRUCT, _imports.size());
    for (std::vector<FileDescriptor::Import*>::const_iterator it = _imports.begin(), itEnd = _imports.end(); it != itEnd; ++it) {
      encoder->writeSharedStruct(*it);
    }
    encoder->writeEndList();
  }
}

// ============================================================================
// FILE
// ============================================================================

static coda::descriptors::StructDescriptor* FILE_Structs[] = {
  &Value::DESCRIPTOR,
  &BoolValue::DESCRIPTOR,
  &IntegerValue::DESCRIPTOR,
  &StringValue::DESCRIPTOR,
  &ListValue::DESCRIPTOR,
  &Options::DESCRIPTOR,
  &FileOptions::DESCRIPTOR,
  &StructOptions::DESCRIPTOR,
  &FieldOptions::DESCRIPTOR,
  &MethodOptions::DESCRIPTOR,
  &EnumOptions::DESCRIPTOR,
  &Type::DESCRIPTOR,
  &BooleanType::DESCRIPTOR,
  &IntegerType::DESCRIPTOR,
  &FloatType::DESCRIPTOR,
  &DoubleType::DESCRIPTOR,
  &StringType::DESCRIPTOR,
  &BytesType::DESCRIPTOR,
  &CollectionType::DESCRIPTOR,
  &ListType::DESCRIPTOR,
  &SetType::DESCRIPTOR,
  &MapType::DESCRIPTOR,
  &ModifiedType::DESCRIPTOR,
  &DeclType::DESCRIPTOR,
  &StructType::DESCRIPTOR,
  &EnumType::DESCRIPTOR,
  &ExtensionField::DESCRIPTOR,
  &FileDescriptor::DESCRIPTOR,
};

static coda::descriptors::EnumDescriptor* FILE_Enums[] = {
  &TypeKind_DESCRIPTOR,
};

coda::descriptors::StaticFileDescriptor FILE(
    "descriptors.coda",
    "coda.descriptors",
    _options1,
    FILE_Structs,
    FILE_Enums
);

} // namespace coda
} // namespace descriptors
