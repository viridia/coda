// ============================================================================
// Generated by codagen from descriptors.coda.coda. DO NOT EDIT!
// ============================================================================

#ifndef CODA_RUNTIME_DESCRIPTORS_GENERATED
#define CODA_RUNTIME_DESCRIPTORS_GENERATED 1

#ifndef CODA_RUNTIME_OBJECT_H
  #include "coda/runtime/object.h"
#endif

#include <bitset>
#include <stdint.h>
#include "coda/runtime/descriptors_mixin.h"

namespace coda {
namespace descriptors {

// Forward declarations
class EnumType;
class ExtensionField;
class FileDescriptor;
class StructType;

enum TypeKind {
  TYPE_KIND_TYPE = 0,
  TYPE_KIND_BOOL = 1,
  TYPE_KIND_INTEGER = 2,
  TYPE_KIND_FLOAT = 3,
  TYPE_KIND_DOUBLE = 4,
  TYPE_KIND_STRING = 5,
  TYPE_KIND_BYTES = 6,
  TYPE_KIND_LIST = 20,
  TYPE_KIND_SET = 21,
  TYPE_KIND_MAP = 22,
  TYPE_KIND_MODIFIED = 23,
  TYPE_KIND_STRUCT = 30,
  TYPE_KIND_ENUM = 31,
  TYPE_KIND_EXTERN = 32,
  TYPE_KIND_COLLECTION = 40,
  TYPE_KIND_DECL = 41,
};

// ============================================================================
// Value
// ============================================================================

class Value : public coda::runtime::Object {
public:
  Value()
  {}

  Value(const Value& _src)
  {}

  coda::descriptors::StructDescriptor* descriptor() const {
    return &DESCRIPTOR;
  }

  coda::runtime::Object* clone() const {
    return new Value(*this);
  }

  static coda::descriptors::StructDescriptor DESCRIPTOR;
  static Value DEFAULT_INSTANCE;
  static const uint32_t TYPE_ID;
};

// ============================================================================
// BoolValue
// ============================================================================

class BoolValue : public Value {
public:
  enum FieldPresentBits {
    HAS_VALUE,
  };

  BoolValue()
    : _value(false)
  {}

  BoolValue(const BoolValue& _src)
    : Value(*this)
    , _value(_src._value)
  {}

  coda::descriptors::StructDescriptor* descriptor() const {
    return &DESCRIPTOR;
  }

  coda::runtime::Object* clone() const {
    return new BoolValue(*this);
  }

  bool equals(const coda::runtime::Object* other) const;
  size_t hashValue() const;
  void freezeImpl();
  void beginWrite(coda::io::Encoder* encoder) const;
  void endWrite(coda::io::Encoder* encoder) const;

  bool hasValue() const {
    return fieldsPresent.test(HAS_VALUE);
  }

  bool isValue() const {
    return _value;
  }

  BoolValue& setValue(bool value) {
    checkMutable();
    fieldsPresent.set(HAS_VALUE);
    _value = value;
    return *this;
  }

  BoolValue& clearValue() {
    checkMutable();
    fieldsPresent.reset(HAS_VALUE);
    _value = false;
    return *this;
  }

  static coda::descriptors::StructDescriptor DESCRIPTOR;
  static BoolValue DEFAULT_INSTANCE;
  static const uint32_t TYPE_ID;

private:
  std::bitset<1> fieldsPresent;
  bool _value;

  static coda::descriptors::FieldDescriptor Field_value;
  static coda::descriptors::FieldDescriptor* Fields[];
};

// ============================================================================
// IntegerValue
// ============================================================================

class IntegerValue : public Value {
public:
  enum FieldPresentBits {
    HAS_VALUE,
  };

  IntegerValue()
    : _value(0)
  {}

  IntegerValue(const IntegerValue& _src)
    : Value(*this)
    , _value(_src._value)
  {}

  coda::descriptors::StructDescriptor* descriptor() const {
    return &DESCRIPTOR;
  }

  coda::runtime::Object* clone() const {
    return new IntegerValue(*this);
  }

  bool equals(const coda::runtime::Object* other) const;
  size_t hashValue() const;
  void freezeImpl();
  void beginWrite(coda::io::Encoder* encoder) const;
  void endWrite(coda::io::Encoder* encoder) const;

  bool hasValue() const {
    return fieldsPresent.test(HAS_VALUE);
  }

  int32_t getValue() const {
    return _value;
  }

  IntegerValue& setValue(int32_t value) {
    checkMutable();
    fieldsPresent.set(HAS_VALUE);
    _value = value;
    return *this;
  }

  IntegerValue& clearValue() {
    checkMutable();
    fieldsPresent.reset(HAS_VALUE);
    _value = 0;
    return *this;
  }

  static coda::descriptors::StructDescriptor DESCRIPTOR;
  static IntegerValue DEFAULT_INSTANCE;
  static const uint32_t TYPE_ID;

private:
  std::bitset<1> fieldsPresent;
  int32_t _value;

  static coda::descriptors::FieldDescriptor Field_value;
  static coda::descriptors::FieldDescriptor* Fields[];
};

// ============================================================================
// StringValue
// ============================================================================

class StringValue : public Value {
public:
  enum FieldPresentBits {
    HAS_VALUE,
  };

  StringValue()
  {}

  StringValue(const StringValue& _src)
    : Value(*this)
    , _value(_src._value)
  {}

  coda::descriptors::StructDescriptor* descriptor() const {
    return &DESCRIPTOR;
  }

  coda::runtime::Object* clone() const {
    return new StringValue(*this);
  }

  bool equals(const coda::runtime::Object* other) const;
  size_t hashValue() const;
  void freezeImpl();
  void beginWrite(coda::io::Encoder* encoder) const;
  void endWrite(coda::io::Encoder* encoder) const;

  bool hasValue() const {
    return fieldsPresent.test(HAS_VALUE);
  }

  const std::string& getValue() const {
    return _value;
  }

  StringValue& setValue(const std::string& value) {
    checkMutable();
    fieldsPresent.set(HAS_VALUE);
    _value = value;
    return *this;
  }

  StringValue& clearValue() {
    checkMutable();
    fieldsPresent.reset(HAS_VALUE);
    _value.clear();
    return *this;
  }

  static coda::descriptors::StructDescriptor DESCRIPTOR;
  static StringValue DEFAULT_INSTANCE;
  static const uint32_t TYPE_ID;

private:
  std::bitset<1> fieldsPresent;
  std::string _value;

  static coda::descriptors::FieldDescriptor Field_value;
  static coda::descriptors::FieldDescriptor* Fields[];
};

// ============================================================================
// ListValue
// ============================================================================

class ListValue : public Value {
public:
  ListValue()
  {}

  ListValue(const ListValue& _src)
    : Value(*this)
    , _value(_src._value)
  {}

  coda::descriptors::StructDescriptor* descriptor() const {
    return &DESCRIPTOR;
  }

  coda::runtime::Object* clone() const {
    return new ListValue(*this);
  }

  bool equals(const coda::runtime::Object* other) const;
  size_t hashValue() const;
  void freezeImpl();
  void beginWrite(coda::io::Encoder* encoder) const;
  void endWrite(coda::io::Encoder* encoder) const;

  const std::vector<Value*>& getValue() const {
    return _value;
  }

  std::vector<Value*>& getMutableValue() {
    checkMutable();
    return _value;
  }

  ListValue& setValue(const std::vector<Value*>& value) {
    checkMutable();
    _value = value;
    return *this;
  }

  ListValue& clearValue() {
    checkMutable();
    _value.clear();
    return *this;
  }

  static coda::descriptors::StructDescriptor DESCRIPTOR;
  static ListValue DEFAULT_INSTANCE;
  static const uint32_t TYPE_ID;

private:
  std::vector<Value*> _value;

  static coda::descriptors::FieldDescriptor Field_value;
  static coda::descriptors::FieldDescriptor* Fields[];
};

// ============================================================================
// Options
// ============================================================================

class Options : public coda::runtime::Object {
public:
  Options()
  {}

  Options(const Options& _src)
  {}

  coda::descriptors::StructDescriptor* descriptor() const {
    return &DESCRIPTOR;
  }

  coda::runtime::Object* clone() const {
    return new Options(*this);
  }

  static coda::descriptors::StructDescriptor DESCRIPTOR;
  static Options DEFAULT_INSTANCE;
  static const uint32_t TYPE_ID;
};

// ============================================================================
// FileOptions
// ============================================================================

class FileOptions : public Options {
public:
  FileOptions()
  {}

  FileOptions(const FileOptions& _src)
    : Options(*this)
    , _package(_src._package)
    , _outerClass(_src._outerClass)
    , _filepath(_src._filepath)
    , _imports(_src._imports)
  {}

  coda::descriptors::StructDescriptor* descriptor() const {
    return &DESCRIPTOR;
  }

  coda::runtime::Object* clone() const {
    return new FileOptions(*this);
  }

  bool equals(const coda::runtime::Object* other) const;
  size_t hashValue() const;
  void freezeImpl();
  void beginWrite(coda::io::Encoder* encoder) const;
  void endWrite(coda::io::Encoder* encoder) const;

  const std::unordered_map<std::string, std::string >& getPackage() const {
    return _package;
  }

  std::unordered_map<std::string, std::string >& getMutablePackage() {
    checkMutable();
    return _package;
  }

  FileOptions& putPackage(const std::string& key, const std::string& value) {
    checkMutable();
    _package[key] = value;
    return *this;
  }

  FileOptions& setPackage(const std::unordered_map<std::string, std::string >& package) {
    checkMutable();
    _package = package;
    return *this;
  }

  FileOptions& clearPackage() {
    checkMutable();
    _package.clear();
    return *this;
  }

  const std::unordered_map<std::string, std::string >& getOuterClass() const {
    return _outerClass;
  }

  std::unordered_map<std::string, std::string >& getMutableOuterClass() {
    checkMutable();
    return _outerClass;
  }

  FileOptions& putOuterClass(const std::string& key, const std::string& value) {
    checkMutable();
    _outerClass[key] = value;
    return *this;
  }

  FileOptions& setOuterClass(const std::unordered_map<std::string, std::string >& outerClass) {
    checkMutable();
    _outerClass = outerClass;
    return *this;
  }

  FileOptions& clearOuterClass() {
    checkMutable();
    _outerClass.clear();
    return *this;
  }

  const std::unordered_map<std::string, std::string >& getFilepath() const {
    return _filepath;
  }

  std::unordered_map<std::string, std::string >& getMutableFilepath() {
    checkMutable();
    return _filepath;
  }

  FileOptions& putFilepath(const std::string& key, const std::string& value) {
    checkMutable();
    _filepath[key] = value;
    return *this;
  }

  FileOptions& setFilepath(const std::unordered_map<std::string, std::string >& filepath) {
    checkMutable();
    _filepath = filepath;
    return *this;
  }

  FileOptions& clearFilepath() {
    checkMutable();
    _filepath.clear();
    return *this;
  }

  const std::unordered_map<std::string, std::vector<std::string> >& getImports() const {
    return _imports;
  }

  std::unordered_map<std::string, std::vector<std::string> >& getMutableImports() {
    checkMutable();
    return _imports;
  }

  FileOptions& putImports(const std::string& key, const std::vector<std::string>& value) {
    checkMutable();
    _imports[key] = value;
    return *this;
  }

  FileOptions& setImports(const std::unordered_map<std::string, std::vector<std::string> >& imports) {
    checkMutable();
    _imports = imports;
    return *this;
  }

  FileOptions& clearImports() {
    checkMutable();
    _imports.clear();
    return *this;
  }

  static coda::descriptors::StructDescriptor DESCRIPTOR;
  static FileOptions DEFAULT_INSTANCE;
  static const uint32_t TYPE_ID;

private:
  std::unordered_map<std::string, std::string > _package;
  std::unordered_map<std::string, std::string > _outerClass;
  std::unordered_map<std::string, std::string > _filepath;
  std::unordered_map<std::string, std::vector<std::string> > _imports;

  static coda::descriptors::FieldDescriptor Field_package;
  static coda::descriptors::FieldDescriptor Field_outerClass;
  static coda::descriptors::FieldDescriptor Field_filepath;
  static coda::descriptors::FieldDescriptor Field_imports;
  static coda::descriptors::FieldDescriptor* Fields[];
};

// ============================================================================
// StructOptions
// ============================================================================

class StructOptions : public Options {
public:
  enum FieldPresentBits {
    HAS_ALLOW_SUBTYPES,
    HAS_REFERENCE,
    HAS_SHARED,
  };

  StructOptions()
    : _allowSubtypes(false)
    , _reference(false)
    , _shared(false)
  {}

  StructOptions(const StructOptions& _src)
    : Options(*this)
    , _allowSubtypes(_src._allowSubtypes)
    , _genClassName(_src._genClassName)
    , _mixin(_src._mixin)
    , _reference(_src._reference)
    , _shared(_src._shared)
  {}

  coda::descriptors::StructDescriptor* descriptor() const {
    return &DESCRIPTOR;
  }

  coda::runtime::Object* clone() const {
    return new StructOptions(*this);
  }

  bool equals(const coda::runtime::Object* other) const;
  size_t hashValue() const;
  void freezeImpl();
  void beginWrite(coda::io::Encoder* encoder) const;
  void endWrite(coda::io::Encoder* encoder) const;

  bool hasAllowSubtypes() const {
    return fieldsPresent.test(HAS_ALLOW_SUBTYPES);
  }

  bool isAllowSubtypes() const {
    return _allowSubtypes;
  }

  StructOptions& setAllowSubtypes(bool allowSubtypes) {
    checkMutable();
    fieldsPresent.set(HAS_ALLOW_SUBTYPES);
    _allowSubtypes = allowSubtypes;
    return *this;
  }

  StructOptions& clearAllowSubtypes() {
    checkMutable();
    fieldsPresent.reset(HAS_ALLOW_SUBTYPES);
    _allowSubtypes = false;
    return *this;
  }

  const std::unordered_map<std::string, std::string >& getGenClassName() const {
    return _genClassName;
  }

  std::unordered_map<std::string, std::string >& getMutableGenClassName() {
    checkMutable();
    return _genClassName;
  }

  StructOptions& putGenClassName(const std::string& key, const std::string& value) {
    checkMutable();
    _genClassName[key] = value;
    return *this;
  }

  StructOptions& setGenClassName(const std::unordered_map<std::string, std::string >& genClassName) {
    checkMutable();
    _genClassName = genClassName;
    return *this;
  }

  StructOptions& clearGenClassName() {
    checkMutable();
    _genClassName.clear();
    return *this;
  }

  const std::unordered_map<std::string, std::string >& getMixin() const {
    return _mixin;
  }

  std::unordered_map<std::string, std::string >& getMutableMixin() {
    checkMutable();
    return _mixin;
  }

  StructOptions& putMixin(const std::string& key, const std::string& value) {
    checkMutable();
    _mixin[key] = value;
    return *this;
  }

  StructOptions& setMixin(const std::unordered_map<std::string, std::string >& mixin) {
    checkMutable();
    _mixin = mixin;
    return *this;
  }

  StructOptions& clearMixin() {
    checkMutable();
    _mixin.clear();
    return *this;
  }

  bool hasReference() const {
    return fieldsPresent.test(HAS_REFERENCE);
  }

  bool isReference() const {
    return _reference;
  }

  StructOptions& setReference(bool reference) {
    checkMutable();
    fieldsPresent.set(HAS_REFERENCE);
    _reference = reference;
    return *this;
  }

  StructOptions& clearReference() {
    checkMutable();
    fieldsPresent.reset(HAS_REFERENCE);
    _reference = false;
    return *this;
  }

  bool hasShared() const {
    return fieldsPresent.test(HAS_SHARED);
  }

  bool isShared() const {
    return _shared;
  }

  StructOptions& setShared(bool shared) {
    checkMutable();
    fieldsPresent.set(HAS_SHARED);
    _shared = shared;
    return *this;
  }

  StructOptions& clearShared() {
    checkMutable();
    fieldsPresent.reset(HAS_SHARED);
    _shared = false;
    return *this;
  }

  static coda::descriptors::StructDescriptor DESCRIPTOR;
  static StructOptions DEFAULT_INSTANCE;
  static const uint32_t TYPE_ID;

private:
  std::bitset<3> fieldsPresent;
  bool _allowSubtypes;
  std::unordered_map<std::string, std::string > _genClassName;
  std::unordered_map<std::string, std::string > _mixin;
  bool _reference;
  bool _shared;

  static coda::descriptors::FieldDescriptor Field_allowSubtypes;
  static coda::descriptors::FieldDescriptor Field_genClassName;
  static coda::descriptors::FieldDescriptor Field_mixin;
  static coda::descriptors::FieldDescriptor Field_reference;
  static coda::descriptors::FieldDescriptor Field_shared;
  static coda::descriptors::FieldDescriptor* Fields[];
};

// ============================================================================
// FieldOptions
// ============================================================================

class FieldOptions : public Options {
public:
  enum FieldPresentBits {
    HAS_NULLABLE,
    HAS_DEPRECATED,
    HAS_FIXED,
    HAS_TRANSIENT,
    HAS_DEFAULT,
    HAS_NOVISIT,
  };

  FieldOptions()
    : _nullable(false)
    , _deprecated(false)
    , _fixed(false)
    , _transient(false)
    , _default(NULL)
    , _novisit(false)
  {}

  FieldOptions(const FieldOptions& _src)
    : Options(*this)
    , _nullable(_src._nullable)
    , _deprecated(_src._deprecated)
    , _fixed(_src._fixed)
    , _transient(_src._transient)
    , _ignore(_src._ignore)
    , _default(_src._default)
    , _novisit(_src._novisit)
  {}

  coda::descriptors::StructDescriptor* descriptor() const {
    return &DESCRIPTOR;
  }

  coda::runtime::Object* clone() const {
    return new FieldOptions(*this);
  }

  bool equals(const coda::runtime::Object* other) const;
  size_t hashValue() const;
  void freezeImpl();
  void beginWrite(coda::io::Encoder* encoder) const;
  void endWrite(coda::io::Encoder* encoder) const;

  bool hasNullable() const {
    return fieldsPresent.test(HAS_NULLABLE);
  }

  bool isNullable() const {
    return _nullable;
  }

  FieldOptions& setNullable(bool nullable) {
    checkMutable();
    fieldsPresent.set(HAS_NULLABLE);
    _nullable = nullable;
    return *this;
  }

  FieldOptions& clearNullable() {
    checkMutable();
    fieldsPresent.reset(HAS_NULLABLE);
    _nullable = false;
    return *this;
  }

  bool hasDeprecated() const {
    return fieldsPresent.test(HAS_DEPRECATED);
  }

  bool isDeprecated() const {
    return _deprecated;
  }

  FieldOptions& setDeprecated(bool deprecated) {
    checkMutable();
    fieldsPresent.set(HAS_DEPRECATED);
    _deprecated = deprecated;
    return *this;
  }

  FieldOptions& clearDeprecated() {
    checkMutable();
    fieldsPresent.reset(HAS_DEPRECATED);
    _deprecated = false;
    return *this;
  }

  bool hasFixed() const {
    return fieldsPresent.test(HAS_FIXED);
  }

  bool isFixed() const {
    return _fixed;
  }

  FieldOptions& setFixed(bool fixed) {
    checkMutable();
    fieldsPresent.set(HAS_FIXED);
    _fixed = fixed;
    return *this;
  }

  FieldOptions& clearFixed() {
    checkMutable();
    fieldsPresent.reset(HAS_FIXED);
    _fixed = false;
    return *this;
  }

  bool hasTransient() const {
    return fieldsPresent.test(HAS_TRANSIENT);
  }

  bool isTransient() const {
    return _transient;
  }

  FieldOptions& setTransient(bool transient) {
    checkMutable();
    fieldsPresent.set(HAS_TRANSIENT);
    _transient = transient;
    return *this;
  }

  FieldOptions& clearTransient() {
    checkMutable();
    fieldsPresent.reset(HAS_TRANSIENT);
    _transient = false;
    return *this;
  }

  const std::unordered_map<std::string, bool>& getIgnore() const {
    return _ignore;
  }

  std::unordered_map<std::string, bool>& getMutableIgnore() {
    checkMutable();
    return _ignore;
  }

  FieldOptions& putIgnore(const std::string& key, bool value) {
    checkMutable();
    _ignore[key] = value;
    return *this;
  }

  FieldOptions& setIgnore(const std::unordered_map<std::string, bool>& ignore) {
    checkMutable();
    _ignore = ignore;
    return *this;
  }

  FieldOptions& clearIgnore() {
    checkMutable();
    _ignore.clear();
    return *this;
  }

  bool hasDefault() const {
    return fieldsPresent.test(HAS_DEFAULT);
  }

  const Value* getDefault() const {
    return _default;
  }

  Value* getMutableDefault() {
    checkMutable();
    fieldsPresent.set(HAS_DEFAULT);
    return _default;
  }

  FieldOptions& setDefault(Value* v_default) {
    checkMutable();
    fieldsPresent.set(HAS_DEFAULT);
    _default = v_default;
    return *this;
  }

  FieldOptions& clearDefault() {
    checkMutable();
    fieldsPresent.reset(HAS_DEFAULT);
    _default = NULL;
    return *this;
  }

  bool hasNovisit() const {
    return fieldsPresent.test(HAS_NOVISIT);
  }

  bool isNovisit() const {
    return _novisit;
  }

  FieldOptions& setNovisit(bool novisit) {
    checkMutable();
    fieldsPresent.set(HAS_NOVISIT);
    _novisit = novisit;
    return *this;
  }

  FieldOptions& clearNovisit() {
    checkMutable();
    fieldsPresent.reset(HAS_NOVISIT);
    _novisit = false;
    return *this;
  }

  static coda::descriptors::StructDescriptor DESCRIPTOR;
  static FieldOptions DEFAULT_INSTANCE;
  static const uint32_t TYPE_ID;

private:
  std::bitset<6> fieldsPresent;
  bool _nullable;
  bool _deprecated;
  bool _fixed;
  bool _transient;
  std::unordered_map<std::string, bool> _ignore;
  Value* _default;
  bool _novisit;

  static coda::descriptors::FieldDescriptor Field_nullable;
  static coda::descriptors::FieldDescriptor Field_deprecated;
  static coda::descriptors::FieldDescriptor Field_fixed;
  static coda::descriptors::FieldDescriptor Field_transient;
  static coda::descriptors::FieldDescriptor Field_ignore;
  static coda::descriptors::FieldDescriptor Field_default;
  static coda::descriptors::FieldDescriptor Field_novisit;
  static coda::descriptors::FieldDescriptor* Fields[];
};

// ============================================================================
// MethodOptions
// ============================================================================

class MethodOptions : public Options {
public:
  enum FieldPresentBits {
    HAS_CONST,
  };

  MethodOptions()
    : _const(false)
  {}

  MethodOptions(const MethodOptions& _src)
    : Options(*this)
    , _const(_src._const)
  {}

  coda::descriptors::StructDescriptor* descriptor() const {
    return &DESCRIPTOR;
  }

  coda::runtime::Object* clone() const {
    return new MethodOptions(*this);
  }

  bool equals(const coda::runtime::Object* other) const;
  size_t hashValue() const;
  void freezeImpl();
  void beginWrite(coda::io::Encoder* encoder) const;
  void endWrite(coda::io::Encoder* encoder) const;

  bool hasConst() const {
    return fieldsPresent.test(HAS_CONST);
  }

  bool isConst() const {
    return _const;
  }

  MethodOptions& setConst(bool v_const) {
    checkMutable();
    fieldsPresent.set(HAS_CONST);
    _const = v_const;
    return *this;
  }

  MethodOptions& clearConst() {
    checkMutable();
    fieldsPresent.reset(HAS_CONST);
    _const = false;
    return *this;
  }

  static coda::descriptors::StructDescriptor DESCRIPTOR;
  static MethodOptions DEFAULT_INSTANCE;
  static const uint32_t TYPE_ID;

private:
  std::bitset<1> fieldsPresent;
  bool _const;

  static coda::descriptors::FieldDescriptor Field_const;
  static coda::descriptors::FieldDescriptor* Fields[];
};

// ============================================================================
// EnumOptions
// ============================================================================

class EnumOptions : public Options {
public:
  EnumOptions()
  {}

  EnumOptions(const EnumOptions& _src)
    : Options(*this)
  {}

  coda::descriptors::StructDescriptor* descriptor() const {
    return &DESCRIPTOR;
  }

  coda::runtime::Object* clone() const {
    return new EnumOptions(*this);
  }

  void beginWrite(coda::io::Encoder* encoder) const;
  void endWrite(coda::io::Encoder* encoder) const;
  static coda::descriptors::StructDescriptor DESCRIPTOR;
  static EnumOptions DEFAULT_INSTANCE;
  static const uint32_t TYPE_ID;
};

// ============================================================================
// Type
// ============================================================================

class Type : public coda::runtime::Object, public coda::descriptors::TypeMixin {
public:
  Type()
  {}

  Type(const Type& _src)
  {}

  coda::descriptors::StructDescriptor* descriptor() const {
    return &DESCRIPTOR;
  }

  coda::runtime::Object* clone() const {
    return new Type(*this);
  }

  static coda::descriptors::StructDescriptor DESCRIPTOR;
  static Type DEFAULT_INSTANCE;
  static const uint32_t TYPE_ID;
};

// ============================================================================
// BooleanType
// ============================================================================

class BooleanType : public Type {
public:
  BooleanType()
  {}

  BooleanType(const BooleanType& _src)
    : Type(*this)
  {}

  coda::descriptors::StructDescriptor* descriptor() const {
    return &DESCRIPTOR;
  }

  coda::runtime::Object* clone() const {
    return new BooleanType(*this);
  }

  void beginWrite(coda::io::Encoder* encoder) const;
  void endWrite(coda::io::Encoder* encoder) const;
  static coda::descriptors::StructDescriptor DESCRIPTOR;
  static BooleanType DEFAULT_INSTANCE;
  static const uint32_t TYPE_ID;
};

// ============================================================================
// IntegerType
// ============================================================================

class IntegerType : public Type {
public:
  enum FieldPresentBits {
    HAS_BITS,
  };

  IntegerType()
    : _bits(0)
  {}

  IntegerType(const IntegerType& _src)
    : Type(*this)
    , _bits(_src._bits)
  {}

  coda::descriptors::StructDescriptor* descriptor() const {
    return &DESCRIPTOR;
  }

  coda::runtime::Object* clone() const {
    return new IntegerType(*this);
  }

  bool equals(const coda::runtime::Object* other) const;
  size_t hashValue() const;
  void freezeImpl();
  void beginWrite(coda::io::Encoder* encoder) const;
  void endWrite(coda::io::Encoder* encoder) const;

  bool hasBits() const {
    return fieldsPresent.test(HAS_BITS);
  }

  int32_t getBits() const {
    return _bits;
  }

  IntegerType& setBits(int32_t bits) {
    checkMutable();
    fieldsPresent.set(HAS_BITS);
    _bits = bits;
    return *this;
  }

  IntegerType& clearBits() {
    checkMutable();
    fieldsPresent.reset(HAS_BITS);
    _bits = 0;
    return *this;
  }

  static coda::descriptors::StructDescriptor DESCRIPTOR;
  static IntegerType DEFAULT_INSTANCE;
  static const uint32_t TYPE_ID;

private:
  std::bitset<1> fieldsPresent;
  int32_t _bits;

  static coda::descriptors::FieldDescriptor Field_bits;
  static coda::descriptors::FieldDescriptor* Fields[];
};

// ============================================================================
// FloatType
// ============================================================================

class FloatType : public Type {
public:
  FloatType()
  {}

  FloatType(const FloatType& _src)
    : Type(*this)
  {}

  coda::descriptors::StructDescriptor* descriptor() const {
    return &DESCRIPTOR;
  }

  coda::runtime::Object* clone() const {
    return new FloatType(*this);
  }

  void beginWrite(coda::io::Encoder* encoder) const;
  void endWrite(coda::io::Encoder* encoder) const;
  static coda::descriptors::StructDescriptor DESCRIPTOR;
  static FloatType DEFAULT_INSTANCE;
  static const uint32_t TYPE_ID;
};

// ============================================================================
// DoubleType
// ============================================================================

class DoubleType : public Type {
public:
  DoubleType()
  {}

  DoubleType(const DoubleType& _src)
    : Type(*this)
  {}

  coda::descriptors::StructDescriptor* descriptor() const {
    return &DESCRIPTOR;
  }

  coda::runtime::Object* clone() const {
    return new DoubleType(*this);
  }

  void beginWrite(coda::io::Encoder* encoder) const;
  void endWrite(coda::io::Encoder* encoder) const;
  static coda::descriptors::StructDescriptor DESCRIPTOR;
  static DoubleType DEFAULT_INSTANCE;
  static const uint32_t TYPE_ID;
};

// ============================================================================
// StringType
// ============================================================================

class StringType : public Type {
public:
  StringType()
  {}

  StringType(const StringType& _src)
    : Type(*this)
  {}

  coda::descriptors::StructDescriptor* descriptor() const {
    return &DESCRIPTOR;
  }

  coda::runtime::Object* clone() const {
    return new StringType(*this);
  }

  void beginWrite(coda::io::Encoder* encoder) const;
  void endWrite(coda::io::Encoder* encoder) const;
  static coda::descriptors::StructDescriptor DESCRIPTOR;
  static StringType DEFAULT_INSTANCE;
  static const uint32_t TYPE_ID;
};

// ============================================================================
// BytesType
// ============================================================================

class BytesType : public Type {
public:
  BytesType()
  {}

  BytesType(const BytesType& _src)
    : Type(*this)
  {}

  coda::descriptors::StructDescriptor* descriptor() const {
    return &DESCRIPTOR;
  }

  coda::runtime::Object* clone() const {
    return new BytesType(*this);
  }

  void beginWrite(coda::io::Encoder* encoder) const;
  void endWrite(coda::io::Encoder* encoder) const;
  static coda::descriptors::StructDescriptor DESCRIPTOR;
  static BytesType DEFAULT_INSTANCE;
  static const uint32_t TYPE_ID;
};

// ============================================================================
// CollectionType
// ============================================================================

class CollectionType : public Type {
public:
  CollectionType()
  {}

  CollectionType(const CollectionType& _src)
    : Type(*this)
  {}

  coda::descriptors::StructDescriptor* descriptor() const {
    return &DESCRIPTOR;
  }

  coda::runtime::Object* clone() const {
    return new CollectionType(*this);
  }

  void beginWrite(coda::io::Encoder* encoder) const;
  void endWrite(coda::io::Encoder* encoder) const;
  static coda::descriptors::StructDescriptor DESCRIPTOR;
  static CollectionType DEFAULT_INSTANCE;
  static const uint32_t TYPE_ID;
};

// ============================================================================
// ListType
// ============================================================================

class ListType : public CollectionType {
public:
  enum FieldPresentBits {
    HAS_ELEMENT_TYPE,
  };

  ListType();
  ListType(const ListType& _src)
    : CollectionType(*this)
    , _elementType(_src._elementType)
  {}

  coda::descriptors::StructDescriptor* descriptor() const {
    return &DESCRIPTOR;
  }

  coda::runtime::Object* clone() const {
    return new ListType(*this);
  }

  bool equals(const coda::runtime::Object* other) const;
  size_t hashValue() const;
  void freezeImpl();
  void beginWrite(coda::io::Encoder* encoder) const;
  void endWrite(coda::io::Encoder* encoder) const;

  bool hasElementType() const {
    return fieldsPresent.test(HAS_ELEMENT_TYPE);
  }

  const Type* getElementType() const {
    return _elementType;
  }

  Type* getMutableElementType() {
    checkMutable();
    fieldsPresent.set(HAS_ELEMENT_TYPE);
    return _elementType;
  }

  ListType& setElementType(Type* elementType) {
    checkMutable();
    fieldsPresent.set(HAS_ELEMENT_TYPE);
    _elementType = elementType;
    return *this;
  }

  ListType& clearElementType() {
    checkMutable();
    fieldsPresent.reset(HAS_ELEMENT_TYPE);
    _elementType = NULL;
    return *this;
  }

  static coda::descriptors::StructDescriptor DESCRIPTOR;
  static ListType DEFAULT_INSTANCE;
  static const uint32_t TYPE_ID;

private:
  std::bitset<1> fieldsPresent;
  Type* _elementType;

  static coda::descriptors::FieldDescriptor Field_elementType;
  static coda::descriptors::FieldDescriptor* Fields[];
};

// ============================================================================
// SetType
// ============================================================================

class SetType : public CollectionType {
public:
  enum FieldPresentBits {
    HAS_ELEMENT_TYPE,
  };

  SetType();
  SetType(const SetType& _src)
    : CollectionType(*this)
    , _elementType(_src._elementType)
  {}

  coda::descriptors::StructDescriptor* descriptor() const {
    return &DESCRIPTOR;
  }

  coda::runtime::Object* clone() const {
    return new SetType(*this);
  }

  bool equals(const coda::runtime::Object* other) const;
  size_t hashValue() const;
  void freezeImpl();
  void beginWrite(coda::io::Encoder* encoder) const;
  void endWrite(coda::io::Encoder* encoder) const;

  bool hasElementType() const {
    return fieldsPresent.test(HAS_ELEMENT_TYPE);
  }

  const Type* getElementType() const {
    return _elementType;
  }

  Type* getMutableElementType() {
    checkMutable();
    fieldsPresent.set(HAS_ELEMENT_TYPE);
    return _elementType;
  }

  SetType& setElementType(Type* elementType) {
    checkMutable();
    fieldsPresent.set(HAS_ELEMENT_TYPE);
    _elementType = elementType;
    return *this;
  }

  SetType& clearElementType() {
    checkMutable();
    fieldsPresent.reset(HAS_ELEMENT_TYPE);
    _elementType = NULL;
    return *this;
  }

  static coda::descriptors::StructDescriptor DESCRIPTOR;
  static SetType DEFAULT_INSTANCE;
  static const uint32_t TYPE_ID;

private:
  std::bitset<1> fieldsPresent;
  Type* _elementType;

  static coda::descriptors::FieldDescriptor Field_elementType;
  static coda::descriptors::FieldDescriptor* Fields[];
};

// ============================================================================
// MapType
// ============================================================================

class MapType : public CollectionType {
public:
  enum FieldPresentBits {
    HAS_KEY_TYPE,
    HAS_VALUE_TYPE,
  };

  MapType();
  MapType(const MapType& _src)
    : CollectionType(*this)
    , _keyType(_src._keyType)
    , _valueType(_src._valueType)
  {}

  coda::descriptors::StructDescriptor* descriptor() const {
    return &DESCRIPTOR;
  }

  coda::runtime::Object* clone() const {
    return new MapType(*this);
  }

  bool equals(const coda::runtime::Object* other) const;
  size_t hashValue() const;
  void freezeImpl();
  void beginWrite(coda::io::Encoder* encoder) const;
  void endWrite(coda::io::Encoder* encoder) const;

  bool hasKeyType() const {
    return fieldsPresent.test(HAS_KEY_TYPE);
  }

  const Type* getKeyType() const {
    return _keyType;
  }

  Type* getMutableKeyType() {
    checkMutable();
    fieldsPresent.set(HAS_KEY_TYPE);
    return _keyType;
  }

  MapType& setKeyType(Type* keyType) {
    checkMutable();
    fieldsPresent.set(HAS_KEY_TYPE);
    _keyType = keyType;
    return *this;
  }

  MapType& clearKeyType() {
    checkMutable();
    fieldsPresent.reset(HAS_KEY_TYPE);
    _keyType = NULL;
    return *this;
  }

  bool hasValueType() const {
    return fieldsPresent.test(HAS_VALUE_TYPE);
  }

  const Type* getValueType() const {
    return _valueType;
  }

  Type* getMutableValueType() {
    checkMutable();
    fieldsPresent.set(HAS_VALUE_TYPE);
    return _valueType;
  }

  MapType& setValueType(Type* valueType) {
    checkMutable();
    fieldsPresent.set(HAS_VALUE_TYPE);
    _valueType = valueType;
    return *this;
  }

  MapType& clearValueType() {
    checkMutable();
    fieldsPresent.reset(HAS_VALUE_TYPE);
    _valueType = NULL;
    return *this;
  }

  static coda::descriptors::StructDescriptor DESCRIPTOR;
  static MapType DEFAULT_INSTANCE;
  static const uint32_t TYPE_ID;

private:
  std::bitset<2> fieldsPresent;
  Type* _keyType;
  Type* _valueType;

  static coda::descriptors::FieldDescriptor Field_keyType;
  static coda::descriptors::FieldDescriptor Field_valueType;
  static coda::descriptors::FieldDescriptor* Fields[];
};

// ============================================================================
// ModifiedType
// ============================================================================

class ModifiedType : public Type {
public:
  enum FieldPresentBits {
    HAS_ELEMENT_TYPE,
    HAS_CONST,
    HAS_SHARED,
  };

  ModifiedType();
  ModifiedType(const ModifiedType& _src)
    : Type(*this)
    , _elementType(_src._elementType)
    , _const(_src._const)
    , _shared(_src._shared)
  {}

  coda::descriptors::StructDescriptor* descriptor() const {
    return &DESCRIPTOR;
  }

  coda::runtime::Object* clone() const {
    return new ModifiedType(*this);
  }

  bool equals(const coda::runtime::Object* other) const;
  size_t hashValue() const;
  void freezeImpl();
  void beginWrite(coda::io::Encoder* encoder) const;
  void endWrite(coda::io::Encoder* encoder) const;

  bool hasElementType() const {
    return fieldsPresent.test(HAS_ELEMENT_TYPE);
  }

  const Type* getElementType() const {
    return _elementType;
  }

  Type* getMutableElementType() {
    checkMutable();
    fieldsPresent.set(HAS_ELEMENT_TYPE);
    return _elementType;
  }

  ModifiedType& setElementType(Type* elementType) {
    checkMutable();
    fieldsPresent.set(HAS_ELEMENT_TYPE);
    _elementType = elementType;
    return *this;
  }

  ModifiedType& clearElementType() {
    checkMutable();
    fieldsPresent.reset(HAS_ELEMENT_TYPE);
    _elementType = NULL;
    return *this;
  }

  bool hasConst() const {
    return fieldsPresent.test(HAS_CONST);
  }

  bool isConst() const {
    return _const;
  }

  ModifiedType& setConst(bool v_const) {
    checkMutable();
    fieldsPresent.set(HAS_CONST);
    _const = v_const;
    return *this;
  }

  ModifiedType& clearConst() {
    checkMutable();
    fieldsPresent.reset(HAS_CONST);
    _const = false;
    return *this;
  }

  bool hasShared() const {
    return fieldsPresent.test(HAS_SHARED);
  }

  bool isShared() const {
    return _shared;
  }

  ModifiedType& setShared(bool shared) {
    checkMutable();
    fieldsPresent.set(HAS_SHARED);
    _shared = shared;
    return *this;
  }

  ModifiedType& clearShared() {
    checkMutable();
    fieldsPresent.reset(HAS_SHARED);
    _shared = false;
    return *this;
  }

  static coda::descriptors::StructDescriptor DESCRIPTOR;
  static ModifiedType DEFAULT_INSTANCE;
  static const uint32_t TYPE_ID;

private:
  std::bitset<3> fieldsPresent;
  Type* _elementType;
  bool _const;
  bool _shared;

  static coda::descriptors::FieldDescriptor Field_elementType;
  static coda::descriptors::FieldDescriptor Field_const;
  static coda::descriptors::FieldDescriptor Field_shared;
  static coda::descriptors::FieldDescriptor* Fields[];
};

// ============================================================================
// DeclType
// ============================================================================

class DeclType : public Type, public coda::descriptors::DeclTypeMixin {
public:
  enum FieldPresentBits {
    HAS_FILE,
    HAS_ENCLOSING_TYPE,
    HAS_NAME,
    HAS_SOURCE_LINE,
  };

  DeclType()
    : _file(NULL)
    , _enclosingType(NULL)
    , _sourceLine(0)
  {}

  DeclType(const DeclType& _src)
    : Type(*this)
    , _file(_src._file)
    , _enclosingType(_src._enclosingType)
    , _name(_src._name)
    , _sourceLine(_src._sourceLine)
  {}

  coda::descriptors::StructDescriptor* descriptor() const {
    return &DESCRIPTOR;
  }

  coda::runtime::Object* clone() const {
    return new DeclType(*this);
  }

  bool equals(const coda::runtime::Object* other) const;
  size_t hashValue() const;
  void freezeImpl();
  void beginWrite(coda::io::Encoder* encoder) const;
  void endWrite(coda::io::Encoder* encoder) const;

  bool hasFile() const {
    return fieldsPresent.test(HAS_FILE);
  }

  const FileDescriptor* getFile() const {
    return _file;
  }

  FileDescriptor* getMutableFile() {
    checkMutable();
    fieldsPresent.set(HAS_FILE);
    return _file;
  }

  DeclType& setFile(FileDescriptor* file) {
    checkMutable();
    fieldsPresent.set(HAS_FILE);
    _file = file;
    return *this;
  }

  DeclType& clearFile() {
    checkMutable();
    fieldsPresent.reset(HAS_FILE);
    _file = NULL;
    return *this;
  }

  bool hasEnclosingType() const {
    return fieldsPresent.test(HAS_ENCLOSING_TYPE);
  }

  const StructType* getEnclosingType() const {
    return _enclosingType;
  }

  StructType* getMutableEnclosingType() {
    checkMutable();
    fieldsPresent.set(HAS_ENCLOSING_TYPE);
    return _enclosingType;
  }

  DeclType& setEnclosingType(StructType* enclosingType) {
    checkMutable();
    fieldsPresent.set(HAS_ENCLOSING_TYPE);
    _enclosingType = enclosingType;
    return *this;
  }

  DeclType& clearEnclosingType() {
    checkMutable();
    fieldsPresent.reset(HAS_ENCLOSING_TYPE);
    _enclosingType = NULL;
    return *this;
  }

  bool hasName() const {
    return fieldsPresent.test(HAS_NAME);
  }

  const std::string& getName() const {
    return _name;
  }

  DeclType& setName(const std::string& name) {
    checkMutable();
    fieldsPresent.set(HAS_NAME);
    _name = name;
    return *this;
  }

  DeclType& clearName() {
    checkMutable();
    fieldsPresent.reset(HAS_NAME);
    _name.clear();
    return *this;
  }

  bool hasSourceLine() const {
    return fieldsPresent.test(HAS_SOURCE_LINE);
  }

  int32_t getSourceLine() const {
    return _sourceLine;
  }

  DeclType& setSourceLine(int32_t sourceLine) {
    checkMutable();
    fieldsPresent.set(HAS_SOURCE_LINE);
    _sourceLine = sourceLine;
    return *this;
  }

  DeclType& clearSourceLine() {
    checkMutable();
    fieldsPresent.reset(HAS_SOURCE_LINE);
    _sourceLine = 0;
    return *this;
  }

  static coda::descriptors::StructDescriptor DESCRIPTOR;
  static DeclType DEFAULT_INSTANCE;
  static const uint32_t TYPE_ID;

private:
  std::bitset<4> fieldsPresent;
  FileDescriptor* _file;
  StructType* _enclosingType;
  std::string _name;
  int32_t _sourceLine;

  static coda::descriptors::FieldDescriptor Field_file;
  static coda::descriptors::FieldDescriptor Field_enclosingType;
  static coda::descriptors::FieldDescriptor Field_name;
  static coda::descriptors::FieldDescriptor Field_sourceLine;
  static coda::descriptors::FieldDescriptor* Fields[];
};

// ============================================================================
// StructType
// ============================================================================

class StructType : public DeclType {
public:
  enum FieldPresentBits {
    HAS_OPTIONS,
    HAS_BASE_TYPE,
    HAS_TYPE_ID,
    HAS_MIN_EXTENSION,
    HAS_MAX_EXTENSION,
  };

  // ============================================================================
  // Field
  // ============================================================================

  class Field : public coda::runtime::Object {
  public:
    enum FieldPresentBits {
      HAS_NAME,
      HAS_TYPE,
      HAS_ID,
      HAS_OPTIONS,
    };

    Field();
    Field(const Field& _src)
      : _name(_src._name)
      , _type(_src._type)
      , _id(_src._id)
      , _options(_src._options)
    {}

    coda::descriptors::StructDescriptor* descriptor() const {
      return &DESCRIPTOR;
    }

    coda::runtime::Object* clone() const {
      return new Field(*this);
    }

    bool equals(const coda::runtime::Object* other) const;
    size_t hashValue() const;
    void freezeImpl();
    void endWrite(coda::io::Encoder* encoder) const;

    bool hasName() const {
      return fieldsPresent.test(HAS_NAME);
    }

    const std::string& getName() const {
      return _name;
    }

    Field& setName(const std::string& name) {
      checkMutable();
      fieldsPresent.set(HAS_NAME);
      _name = name;
      return *this;
    }

    Field& clearName() {
      checkMutable();
      fieldsPresent.reset(HAS_NAME);
      _name.clear();
      return *this;
    }

    bool hasType() const {
      return fieldsPresent.test(HAS_TYPE);
    }

    const Type* getType() const {
      return _type;
    }

    Type* getMutableType() {
      checkMutable();
      fieldsPresent.set(HAS_TYPE);
      return _type;
    }

    Field& setType(Type* type) {
      checkMutable();
      fieldsPresent.set(HAS_TYPE);
      _type = type;
      return *this;
    }

    Field& clearType() {
      checkMutable();
      fieldsPresent.reset(HAS_TYPE);
      _type = NULL;
      return *this;
    }

    bool hasId() const {
      return fieldsPresent.test(HAS_ID);
    }

    int32_t getId() const {
      return _id;
    }

    Field& setId(int32_t id) {
      checkMutable();
      fieldsPresent.set(HAS_ID);
      _id = id;
      return *this;
    }

    Field& clearId() {
      checkMutable();
      fieldsPresent.reset(HAS_ID);
      _id = 0;
      return *this;
    }

    bool hasOptions() const {
      return fieldsPresent.test(HAS_OPTIONS);
    }

    const FieldOptions* getOptions() const {
      return _options;
    }

    FieldOptions* getMutableOptions() {
      checkMutable();
      fieldsPresent.set(HAS_OPTIONS);
      return _options;
    }

    Field& setOptions(FieldOptions* options) {
      checkMutable();
      fieldsPresent.set(HAS_OPTIONS);
      _options = options;
      return *this;
    }

    Field& clearOptions() {
      checkMutable();
      fieldsPresent.reset(HAS_OPTIONS);
      _options = NULL;
      return *this;
    }

    static coda::descriptors::StructDescriptor DESCRIPTOR;
    static Field DEFAULT_INSTANCE;
    static const uint32_t TYPE_ID;

  private:
    std::bitset<4> fieldsPresent;
    std::string _name;
    Type* _type;
    int32_t _id;
    FieldOptions* _options;

    static coda::descriptors::FieldDescriptor Field_name;
    static coda::descriptors::FieldDescriptor Field_type;
    static coda::descriptors::FieldDescriptor Field_id;
    static coda::descriptors::FieldDescriptor Field_options;
    static coda::descriptors::FieldDescriptor* Fields[];
  };

  // ============================================================================
  // Param
  // ============================================================================

  class Param : public coda::runtime::Object {
  public:
    enum FieldPresentBits {
      HAS_NAME,
      HAS_TYPE,
    };

    Param();
    Param(const Param& _src)
      : _name(_src._name)
      , _type(_src._type)
    {}

    coda::descriptors::StructDescriptor* descriptor() const {
      return &DESCRIPTOR;
    }

    coda::runtime::Object* clone() const {
      return new Param(*this);
    }

    bool equals(const coda::runtime::Object* other) const;
    size_t hashValue() const;
    void freezeImpl();
    void endWrite(coda::io::Encoder* encoder) const;

    bool hasName() const {
      return fieldsPresent.test(HAS_NAME);
    }

    const std::string& getName() const {
      return _name;
    }

    Param& setName(const std::string& name) {
      checkMutable();
      fieldsPresent.set(HAS_NAME);
      _name = name;
      return *this;
    }

    Param& clearName() {
      checkMutable();
      fieldsPresent.reset(HAS_NAME);
      _name.clear();
      return *this;
    }

    bool hasType() const {
      return fieldsPresent.test(HAS_TYPE);
    }

    const Type* getType() const {
      return _type;
    }

    Type* getMutableType() {
      checkMutable();
      fieldsPresent.set(HAS_TYPE);
      return _type;
    }

    Param& setType(Type* type) {
      checkMutable();
      fieldsPresent.set(HAS_TYPE);
      _type = type;
      return *this;
    }

    Param& clearType() {
      checkMutable();
      fieldsPresent.reset(HAS_TYPE);
      _type = NULL;
      return *this;
    }

    static coda::descriptors::StructDescriptor DESCRIPTOR;
    static Param DEFAULT_INSTANCE;
    static const uint32_t TYPE_ID;

  private:
    std::bitset<2> fieldsPresent;
    std::string _name;
    Type* _type;

    static coda::descriptors::FieldDescriptor Field_name;
    static coda::descriptors::FieldDescriptor Field_type;
    static coda::descriptors::FieldDescriptor* Fields[];
  };

  // ============================================================================
  // Method
  // ============================================================================

  class Method : public coda::runtime::Object {
  public:
    enum FieldPresentBits {
      HAS_NAME,
      HAS_RETURN_TYPE,
      HAS_ID,
      HAS_OPTIONS,
    };

    Method();
    Method(const Method& _src)
      : _name(_src._name)
      , _params(_src._params)
      , _returnType(_src._returnType)
      , _id(_src._id)
      , _options(_src._options)
    {}

    coda::descriptors::StructDescriptor* descriptor() const {
      return &DESCRIPTOR;
    }

    coda::runtime::Object* clone() const {
      return new Method(*this);
    }

    bool equals(const coda::runtime::Object* other) const;
    size_t hashValue() const;
    void freezeImpl();
    void endWrite(coda::io::Encoder* encoder) const;

    bool hasName() const {
      return fieldsPresent.test(HAS_NAME);
    }

    const std::string& getName() const {
      return _name;
    }

    Method& setName(const std::string& name) {
      checkMutable();
      fieldsPresent.set(HAS_NAME);
      _name = name;
      return *this;
    }

    Method& clearName() {
      checkMutable();
      fieldsPresent.reset(HAS_NAME);
      _name.clear();
      return *this;
    }

    const std::vector<StructType::Param*>& getParams() const {
      return _params;
    }

    std::vector<StructType::Param*>& getMutableParams() {
      checkMutable();
      return _params;
    }

    Method& setParams(const std::vector<StructType::Param*>& params) {
      checkMutable();
      _params = params;
      return *this;
    }

    Method& clearParams() {
      checkMutable();
      _params.clear();
      return *this;
    }

    bool hasReturnType() const {
      return fieldsPresent.test(HAS_RETURN_TYPE);
    }

    const Type* getReturnType() const {
      return _returnType;
    }

    Type* getMutableReturnType() {
      checkMutable();
      fieldsPresent.set(HAS_RETURN_TYPE);
      return _returnType;
    }

    Method& setReturnType(Type* returnType) {
      checkMutable();
      fieldsPresent.set(HAS_RETURN_TYPE);
      _returnType = returnType;
      return *this;
    }

    Method& clearReturnType() {
      checkMutable();
      fieldsPresent.reset(HAS_RETURN_TYPE);
      _returnType = NULL;
      return *this;
    }

    bool hasId() const {
      return fieldsPresent.test(HAS_ID);
    }

    int32_t getId() const {
      return _id;
    }

    Method& setId(int32_t id) {
      checkMutable();
      fieldsPresent.set(HAS_ID);
      _id = id;
      return *this;
    }

    Method& clearId() {
      checkMutable();
      fieldsPresent.reset(HAS_ID);
      _id = 0;
      return *this;
    }

    bool hasOptions() const {
      return fieldsPresent.test(HAS_OPTIONS);
    }

    const MethodOptions* getOptions() const {
      return _options;
    }

    MethodOptions* getMutableOptions() {
      checkMutable();
      fieldsPresent.set(HAS_OPTIONS);
      return _options;
    }

    Method& setOptions(MethodOptions* options) {
      checkMutable();
      fieldsPresent.set(HAS_OPTIONS);
      _options = options;
      return *this;
    }

    Method& clearOptions() {
      checkMutable();
      fieldsPresent.reset(HAS_OPTIONS);
      _options = NULL;
      return *this;
    }

    static coda::descriptors::StructDescriptor DESCRIPTOR;
    static Method DEFAULT_INSTANCE;
    static const uint32_t TYPE_ID;

  private:
    std::bitset<4> fieldsPresent;
    std::string _name;
    std::vector<StructType::Param*> _params;
    Type* _returnType;
    int32_t _id;
    MethodOptions* _options;

    static coda::descriptors::FieldDescriptor Field_name;
    static coda::descriptors::FieldDescriptor Field_params;
    static coda::descriptors::FieldDescriptor Field_returnType;
    static coda::descriptors::FieldDescriptor Field_id;
    static coda::descriptors::FieldDescriptor Field_options;
    static coda::descriptors::FieldDescriptor* Fields[];
  };

  StructType();
  StructType(const StructType& _src)
    : DeclType(*this)
    , _options(_src._options)
    , _baseType(_src._baseType)
    , _typeId(_src._typeId)
    , _fields(_src._fields)
    , _structs(_src._structs)
    , _enums(_src._enums)
    , _extensions(_src._extensions)
    , _minExtension(_src._minExtension)
    , _maxExtension(_src._maxExtension)
  {}

  coda::descriptors::StructDescriptor* descriptor() const {
    return &DESCRIPTOR;
  }

  coda::runtime::Object* clone() const {
    return new StructType(*this);
  }

  bool equals(const coda::runtime::Object* other) const;
  size_t hashValue() const;
  void freezeImpl();
  void beginWrite(coda::io::Encoder* encoder) const;
  void endWrite(coda::io::Encoder* encoder) const;

  bool hasOptions() const {
    return fieldsPresent.test(HAS_OPTIONS);
  }

  const StructOptions* getOptions() const {
    return _options;
  }

  StructOptions* getMutableOptions() {
    checkMutable();
    fieldsPresent.set(HAS_OPTIONS);
    return _options;
  }

  StructType& setOptions(StructOptions* options) {
    checkMutable();
    fieldsPresent.set(HAS_OPTIONS);
    _options = options;
    return *this;
  }

  StructType& clearOptions() {
    checkMutable();
    fieldsPresent.reset(HAS_OPTIONS);
    _options = NULL;
    return *this;
  }

  bool hasBaseType() const {
    return fieldsPresent.test(HAS_BASE_TYPE);
  }

  const StructType* getBaseType() const {
    return _baseType;
  }

  StructType* getMutableBaseType() {
    checkMutable();
    fieldsPresent.set(HAS_BASE_TYPE);
    return _baseType;
  }

  StructType& setBaseType(StructType* baseType) {
    checkMutable();
    fieldsPresent.set(HAS_BASE_TYPE);
    _baseType = baseType;
    return *this;
  }

  StructType& clearBaseType() {
    checkMutable();
    fieldsPresent.reset(HAS_BASE_TYPE);
    _baseType = NULL;
    return *this;
  }

  bool hasTypeId() const {
    return fieldsPresent.test(HAS_TYPE_ID);
  }

  int32_t getTypeId() const {
    return _typeId;
  }

  StructType& setTypeId(int32_t typeId) {
    checkMutable();
    fieldsPresent.set(HAS_TYPE_ID);
    _typeId = typeId;
    return *this;
  }

  StructType& clearTypeId() {
    checkMutable();
    fieldsPresent.reset(HAS_TYPE_ID);
    _typeId = 0;
    return *this;
  }

  const std::vector<StructType::Field*>& getFields() const {
    return _fields;
  }

  std::vector<StructType::Field*>& getMutableFields() {
    checkMutable();
    return _fields;
  }

  StructType& setFields(const std::vector<StructType::Field*>& fields) {
    checkMutable();
    _fields = fields;
    return *this;
  }

  StructType& clearFields() {
    checkMutable();
    _fields.clear();
    return *this;
  }

  const std::vector<StructType*>& getStructs() const {
    return _structs;
  }

  std::vector<StructType*>& getMutableStructs() {
    checkMutable();
    return _structs;
  }

  StructType& setStructs(const std::vector<StructType*>& structs) {
    checkMutable();
    _structs = structs;
    return *this;
  }

  StructType& clearStructs() {
    checkMutable();
    _structs.clear();
    return *this;
  }

  const std::vector<EnumType*>& getEnums() const {
    return _enums;
  }

  std::vector<EnumType*>& getMutableEnums() {
    checkMutable();
    return _enums;
  }

  StructType& setEnums(const std::vector<EnumType*>& enums) {
    checkMutable();
    _enums = enums;
    return *this;
  }

  StructType& clearEnums() {
    checkMutable();
    _enums.clear();
    return *this;
  }

  const std::vector<ExtensionField*>& getExtensions() const {
    return _extensions;
  }

  std::vector<ExtensionField*>& getMutableExtensions() {
    checkMutable();
    return _extensions;
  }

  StructType& setExtensions(const std::vector<ExtensionField*>& extensions) {
    checkMutable();
    _extensions = extensions;
    return *this;
  }

  StructType& clearExtensions() {
    checkMutable();
    _extensions.clear();
    return *this;
  }

  bool hasMinExtension() const {
    return fieldsPresent.test(HAS_MIN_EXTENSION);
  }

  int32_t getMinExtension() const {
    return _minExtension;
  }

  StructType& setMinExtension(int32_t minExtension) {
    checkMutable();
    fieldsPresent.set(HAS_MIN_EXTENSION);
    _minExtension = minExtension;
    return *this;
  }

  StructType& clearMinExtension() {
    checkMutable();
    fieldsPresent.reset(HAS_MIN_EXTENSION);
    _minExtension = 0;
    return *this;
  }

  bool hasMaxExtension() const {
    return fieldsPresent.test(HAS_MAX_EXTENSION);
  }

  int32_t getMaxExtension() const {
    return _maxExtension;
  }

  StructType& setMaxExtension(int32_t maxExtension) {
    checkMutable();
    fieldsPresent.set(HAS_MAX_EXTENSION);
    _maxExtension = maxExtension;
    return *this;
  }

  StructType& clearMaxExtension() {
    checkMutable();
    fieldsPresent.reset(HAS_MAX_EXTENSION);
    _maxExtension = 0;
    return *this;
  }

  static coda::descriptors::StructDescriptor DESCRIPTOR;
  static StructType DEFAULT_INSTANCE;
  static const uint32_t TYPE_ID;

private:
  std::bitset<5> fieldsPresent;
  StructOptions* _options;
  StructType* _baseType;
  int32_t _typeId;
  std::vector<StructType::Field*> _fields;
  std::vector<StructType*> _structs;
  std::vector<EnumType*> _enums;
  std::vector<ExtensionField*> _extensions;
  int32_t _minExtension;
  int32_t _maxExtension;

  static coda::descriptors::FieldDescriptor Field_options;
  static coda::descriptors::FieldDescriptor Field_baseType;
  static coda::descriptors::FieldDescriptor Field_typeId;
  static coda::descriptors::FieldDescriptor Field_fields;
  static coda::descriptors::FieldDescriptor Field_structs;
  static coda::descriptors::FieldDescriptor Field_enums;
  static coda::descriptors::FieldDescriptor Field_extensions;
  static coda::descriptors::FieldDescriptor Field_minExtension;
  static coda::descriptors::FieldDescriptor Field_maxExtension;
  static coda::descriptors::FieldDescriptor* Fields[];
};

// ============================================================================
// EnumType
// ============================================================================

class EnumType : public DeclType {
public:
  enum FieldPresentBits {
    HAS_OPTIONS,
  };

  // ============================================================================
  // Value
  // ============================================================================

  class Value : public coda::runtime::Object {
  public:
    enum FieldPresentBits {
      HAS_NAME,
      HAS_VALUE,
    };

    Value()
      : _value(0)
    {}

    Value(const Value& _src)
      : _name(_src._name)
      , _value(_src._value)
    {}

    coda::descriptors::StructDescriptor* descriptor() const {
      return &DESCRIPTOR;
    }

    coda::runtime::Object* clone() const {
      return new Value(*this);
    }

    bool equals(const coda::runtime::Object* other) const;
    size_t hashValue() const;
    void freezeImpl();
    void endWrite(coda::io::Encoder* encoder) const;

    bool hasName() const {
      return fieldsPresent.test(HAS_NAME);
    }

    const std::string& getName() const {
      return _name;
    }

    Value& setName(const std::string& name) {
      checkMutable();
      fieldsPresent.set(HAS_NAME);
      _name = name;
      return *this;
    }

    Value& clearName() {
      checkMutable();
      fieldsPresent.reset(HAS_NAME);
      _name.clear();
      return *this;
    }

    bool hasValue() const {
      return fieldsPresent.test(HAS_VALUE);
    }

    int32_t getValue() const {
      return _value;
    }

    Value& setValue(int32_t value) {
      checkMutable();
      fieldsPresent.set(HAS_VALUE);
      _value = value;
      return *this;
    }

    Value& clearValue() {
      checkMutable();
      fieldsPresent.reset(HAS_VALUE);
      _value = 0;
      return *this;
    }

    static coda::descriptors::StructDescriptor DESCRIPTOR;
    static Value DEFAULT_INSTANCE;
    static const uint32_t TYPE_ID;

  private:
    std::bitset<2> fieldsPresent;
    std::string _name;
    int32_t _value;

    static coda::descriptors::FieldDescriptor Field_name;
    static coda::descriptors::FieldDescriptor Field_value;
    static coda::descriptors::FieldDescriptor* Fields[];
  };

  EnumType();
  EnumType(const EnumType& _src)
    : DeclType(*this)
    , _options(_src._options)
    , _values(_src._values)
  {}

  coda::descriptors::StructDescriptor* descriptor() const {
    return &DESCRIPTOR;
  }

  coda::runtime::Object* clone() const {
    return new EnumType(*this);
  }

  bool equals(const coda::runtime::Object* other) const;
  size_t hashValue() const;
  void freezeImpl();
  void beginWrite(coda::io::Encoder* encoder) const;
  void endWrite(coda::io::Encoder* encoder) const;

  bool hasOptions() const {
    return fieldsPresent.test(HAS_OPTIONS);
  }

  const EnumOptions* getOptions() const {
    return _options;
  }

  EnumOptions* getMutableOptions() {
    checkMutable();
    fieldsPresent.set(HAS_OPTIONS);
    return _options;
  }

  EnumType& setOptions(EnumOptions* options) {
    checkMutable();
    fieldsPresent.set(HAS_OPTIONS);
    _options = options;
    return *this;
  }

  EnumType& clearOptions() {
    checkMutable();
    fieldsPresent.reset(HAS_OPTIONS);
    _options = NULL;
    return *this;
  }

  const std::vector<EnumType::Value*>& getValues() const {
    return _values;
  }

  std::vector<EnumType::Value*>& getMutableValues() {
    checkMutable();
    return _values;
  }

  EnumType& setValues(const std::vector<EnumType::Value*>& values) {
    checkMutable();
    _values = values;
    return *this;
  }

  EnumType& clearValues() {
    checkMutable();
    _values.clear();
    return *this;
  }

  static coda::descriptors::StructDescriptor DESCRIPTOR;
  static EnumType DEFAULT_INSTANCE;
  static const uint32_t TYPE_ID;

private:
  std::bitset<1> fieldsPresent;
  EnumOptions* _options;
  std::vector<EnumType::Value*> _values;

  static coda::descriptors::FieldDescriptor Field_options;
  static coda::descriptors::FieldDescriptor Field_values;
  static coda::descriptors::FieldDescriptor* Fields[];
};

// ============================================================================
// ExtensionField
// ============================================================================

class ExtensionField : public coda::runtime::Object {
public:
  enum FieldPresentBits {
    HAS_FILE,
    HAS_ENCLOSING_TYPE,
    HAS_SOURCE_LINE,
    HAS_EXTENDS,
    HAS_NAME,
    HAS_ID,
    HAS_TYPE,
  };

  ExtensionField();
  ExtensionField(const ExtensionField& _src)
    : _file(_src._file)
    , _enclosingType(_src._enclosingType)
    , _sourceLine(_src._sourceLine)
    , _extends(_src._extends)
    , _name(_src._name)
    , _id(_src._id)
    , _type(_src._type)
  {}

  coda::descriptors::StructDescriptor* descriptor() const {
    return &DESCRIPTOR;
  }

  coda::runtime::Object* clone() const {
    return new ExtensionField(*this);
  }

  bool equals(const coda::runtime::Object* other) const;
  size_t hashValue() const;
  void freezeImpl();
  void endWrite(coda::io::Encoder* encoder) const;

  bool hasFile() const {
    return fieldsPresent.test(HAS_FILE);
  }

  const FileDescriptor* getFile() const {
    return _file;
  }

  FileDescriptor* getMutableFile() {
    checkMutable();
    fieldsPresent.set(HAS_FILE);
    return _file;
  }

  ExtensionField& setFile(FileDescriptor* file) {
    checkMutable();
    fieldsPresent.set(HAS_FILE);
    _file = file;
    return *this;
  }

  ExtensionField& clearFile() {
    checkMutable();
    fieldsPresent.reset(HAS_FILE);
    _file = NULL;
    return *this;
  }

  bool hasEnclosingType() const {
    return fieldsPresent.test(HAS_ENCLOSING_TYPE);
  }

  const StructType* getEnclosingType() const {
    return _enclosingType;
  }

  StructType* getMutableEnclosingType() {
    checkMutable();
    fieldsPresent.set(HAS_ENCLOSING_TYPE);
    return _enclosingType;
  }

  ExtensionField& setEnclosingType(StructType* enclosingType) {
    checkMutable();
    fieldsPresent.set(HAS_ENCLOSING_TYPE);
    _enclosingType = enclosingType;
    return *this;
  }

  ExtensionField& clearEnclosingType() {
    checkMutable();
    fieldsPresent.reset(HAS_ENCLOSING_TYPE);
    _enclosingType = NULL;
    return *this;
  }

  bool hasSourceLine() const {
    return fieldsPresent.test(HAS_SOURCE_LINE);
  }

  int32_t getSourceLine() const {
    return _sourceLine;
  }

  ExtensionField& setSourceLine(int32_t sourceLine) {
    checkMutable();
    fieldsPresent.set(HAS_SOURCE_LINE);
    _sourceLine = sourceLine;
    return *this;
  }

  ExtensionField& clearSourceLine() {
    checkMutable();
    fieldsPresent.reset(HAS_SOURCE_LINE);
    _sourceLine = 0;
    return *this;
  }

  bool hasExtends() const {
    return fieldsPresent.test(HAS_EXTENDS);
  }

  const StructType* getExtends() const {
    return _extends;
  }

  StructType* getMutableExtends() {
    checkMutable();
    fieldsPresent.set(HAS_EXTENDS);
    return _extends;
  }

  ExtensionField& setExtends(StructType* extends) {
    checkMutable();
    fieldsPresent.set(HAS_EXTENDS);
    _extends = extends;
    return *this;
  }

  ExtensionField& clearExtends() {
    checkMutable();
    fieldsPresent.reset(HAS_EXTENDS);
    _extends = NULL;
    return *this;
  }

  bool hasName() const {
    return fieldsPresent.test(HAS_NAME);
  }

  const std::string& getName() const {
    return _name;
  }

  ExtensionField& setName(const std::string& name) {
    checkMutable();
    fieldsPresent.set(HAS_NAME);
    _name = name;
    return *this;
  }

  ExtensionField& clearName() {
    checkMutable();
    fieldsPresent.reset(HAS_NAME);
    _name.clear();
    return *this;
  }

  bool hasId() const {
    return fieldsPresent.test(HAS_ID);
  }

  int32_t getId() const {
    return _id;
  }

  ExtensionField& setId(int32_t id) {
    checkMutable();
    fieldsPresent.set(HAS_ID);
    _id = id;
    return *this;
  }

  ExtensionField& clearId() {
    checkMutable();
    fieldsPresent.reset(HAS_ID);
    _id = 0;
    return *this;
  }

  bool hasType() const {
    return fieldsPresent.test(HAS_TYPE);
  }

  const Type* getType() const {
    return _type;
  }

  Type* getMutableType() {
    checkMutable();
    fieldsPresent.set(HAS_TYPE);
    return _type;
  }

  ExtensionField& setType(Type* type) {
    checkMutable();
    fieldsPresent.set(HAS_TYPE);
    _type = type;
    return *this;
  }

  ExtensionField& clearType() {
    checkMutable();
    fieldsPresent.reset(HAS_TYPE);
    _type = NULL;
    return *this;
  }

  static coda::descriptors::StructDescriptor DESCRIPTOR;
  static ExtensionField DEFAULT_INSTANCE;
  static const uint32_t TYPE_ID;

private:
  std::bitset<7> fieldsPresent;
  FileDescriptor* _file;
  StructType* _enclosingType;
  int32_t _sourceLine;
  StructType* _extends;
  std::string _name;
  int32_t _id;
  Type* _type;

  static coda::descriptors::FieldDescriptor Field_file;
  static coda::descriptors::FieldDescriptor Field_enclosingType;
  static coda::descriptors::FieldDescriptor Field_sourceLine;
  static coda::descriptors::FieldDescriptor Field_extends;
  static coda::descriptors::FieldDescriptor Field_name;
  static coda::descriptors::FieldDescriptor Field_id;
  static coda::descriptors::FieldDescriptor Field_type;
  static coda::descriptors::FieldDescriptor* Fields[];
};

// ============================================================================
// FileDescriptor
// ============================================================================

class FileDescriptor : public coda::runtime::Object {
public:
  enum FieldPresentBits {
    HAS_NAME,
    HAS_DIRECTORY,
    HAS_PACKAGE,
    HAS_OPTIONS,
  };

  // ============================================================================
  // Import
  // ============================================================================

  class Import : public coda::runtime::Object {
  public:
    enum FieldPresentBits {
      HAS_PATH,
    };

    Import()
    {}

    Import(const Import& _src)
      : _path(_src._path)
      , _package(_src._package)
    {}

    coda::descriptors::StructDescriptor* descriptor() const {
      return &DESCRIPTOR;
    }

    coda::runtime::Object* clone() const {
      return new Import(*this);
    }

    bool equals(const coda::runtime::Object* other) const;
    size_t hashValue() const;
    void freezeImpl();
    void endWrite(coda::io::Encoder* encoder) const;

    bool hasPath() const {
      return fieldsPresent.test(HAS_PATH);
    }

    const std::string& getPath() const {
      return _path;
    }

    Import& setPath(const std::string& path) {
      checkMutable();
      fieldsPresent.set(HAS_PATH);
      _path = path;
      return *this;
    }

    Import& clearPath() {
      checkMutable();
      fieldsPresent.reset(HAS_PATH);
      _path.clear();
      return *this;
    }

    const std::unordered_map<std::string, std::string >& getPackage() const {
      return _package;
    }

    std::unordered_map<std::string, std::string >& getMutablePackage() {
      checkMutable();
      return _package;
    }

    Import& putPackage(const std::string& key, const std::string& value) {
      checkMutable();
      _package[key] = value;
      return *this;
    }

    Import& setPackage(const std::unordered_map<std::string, std::string >& package) {
      checkMutable();
      _package = package;
      return *this;
    }

    Import& clearPackage() {
      checkMutable();
      _package.clear();
      return *this;
    }

    static coda::descriptors::StructDescriptor DESCRIPTOR;
    static Import DEFAULT_INSTANCE;
    static const uint32_t TYPE_ID;

  private:
    std::bitset<1> fieldsPresent;
    std::string _path;
    std::unordered_map<std::string, std::string > _package;

    static coda::descriptors::FieldDescriptor Field_path;
    static coda::descriptors::FieldDescriptor Field_package;
    static coda::descriptors::FieldDescriptor* Fields[];
  };

  FileDescriptor();
  FileDescriptor(const FileDescriptor& _src)
    : _name(_src._name)
    , _directory(_src._directory)
    , _package(_src._package)
    , _options(_src._options)
    , _structs(_src._structs)
    , _enums(_src._enums)
    , _extensions(_src._extensions)
    , _imports(_src._imports)
  {}

  coda::descriptors::StructDescriptor* descriptor() const {
    return &DESCRIPTOR;
  }

  coda::runtime::Object* clone() const {
    return new FileDescriptor(*this);
  }

  bool equals(const coda::runtime::Object* other) const;
  size_t hashValue() const;
  void freezeImpl();
  void endWrite(coda::io::Encoder* encoder) const;

  bool hasName() const {
    return fieldsPresent.test(HAS_NAME);
  }

  const std::string& getName() const {
    return _name;
  }

  FileDescriptor& setName(const std::string& name) {
    checkMutable();
    fieldsPresent.set(HAS_NAME);
    _name = name;
    return *this;
  }

  FileDescriptor& clearName() {
    checkMutable();
    fieldsPresent.reset(HAS_NAME);
    _name.clear();
    return *this;
  }

  bool hasDirectory() const {
    return fieldsPresent.test(HAS_DIRECTORY);
  }

  const std::string& getDirectory() const {
    return _directory;
  }

  FileDescriptor& setDirectory(const std::string& directory) {
    checkMutable();
    fieldsPresent.set(HAS_DIRECTORY);
    _directory = directory;
    return *this;
  }

  FileDescriptor& clearDirectory() {
    checkMutable();
    fieldsPresent.reset(HAS_DIRECTORY);
    _directory.clear();
    return *this;
  }

  bool hasPackage() const {
    return fieldsPresent.test(HAS_PACKAGE);
  }

  const std::string& getPackage() const {
    return _package;
  }

  FileDescriptor& setPackage(const std::string& package) {
    checkMutable();
    fieldsPresent.set(HAS_PACKAGE);
    _package = package;
    return *this;
  }

  FileDescriptor& clearPackage() {
    checkMutable();
    fieldsPresent.reset(HAS_PACKAGE);
    _package.clear();
    return *this;
  }

  bool hasOptions() const {
    return fieldsPresent.test(HAS_OPTIONS);
  }

  const FileOptions* getOptions() const {
    return _options;
  }

  FileOptions* getMutableOptions() {
    checkMutable();
    fieldsPresent.set(HAS_OPTIONS);
    return _options;
  }

  FileDescriptor& setOptions(FileOptions* options) {
    checkMutable();
    fieldsPresent.set(HAS_OPTIONS);
    _options = options;
    return *this;
  }

  FileDescriptor& clearOptions() {
    checkMutable();
    fieldsPresent.reset(HAS_OPTIONS);
    _options = NULL;
    return *this;
  }

  const std::vector<StructType*>& getStructs() const {
    return _structs;
  }

  std::vector<StructType*>& getMutableStructs() {
    checkMutable();
    return _structs;
  }

  FileDescriptor& setStructs(const std::vector<StructType*>& structs) {
    checkMutable();
    _structs = structs;
    return *this;
  }

  FileDescriptor& clearStructs() {
    checkMutable();
    _structs.clear();
    return *this;
  }

  const std::vector<EnumType*>& getEnums() const {
    return _enums;
  }

  std::vector<EnumType*>& getMutableEnums() {
    checkMutable();
    return _enums;
  }

  FileDescriptor& setEnums(const std::vector<EnumType*>& enums) {
    checkMutable();
    _enums = enums;
    return *this;
  }

  FileDescriptor& clearEnums() {
    checkMutable();
    _enums.clear();
    return *this;
  }

  const std::vector<ExtensionField*>& getExtensions() const {
    return _extensions;
  }

  std::vector<ExtensionField*>& getMutableExtensions() {
    checkMutable();
    return _extensions;
  }

  FileDescriptor& setExtensions(const std::vector<ExtensionField*>& extensions) {
    checkMutable();
    _extensions = extensions;
    return *this;
  }

  FileDescriptor& clearExtensions() {
    checkMutable();
    _extensions.clear();
    return *this;
  }

  const std::vector<FileDescriptor::Import*>& getImports() const {
    return _imports;
  }

  std::vector<FileDescriptor::Import*>& getMutableImports() {
    checkMutable();
    return _imports;
  }

  FileDescriptor& setImports(const std::vector<FileDescriptor::Import*>& imports) {
    checkMutable();
    _imports = imports;
    return *this;
  }

  FileDescriptor& clearImports() {
    checkMutable();
    _imports.clear();
    return *this;
  }

  static coda::descriptors::StructDescriptor DESCRIPTOR;
  static FileDescriptor DEFAULT_INSTANCE;
  static const uint32_t TYPE_ID;

private:
  std::bitset<4> fieldsPresent;
  std::string _name;
  std::string _directory;
  std::string _package;
  FileOptions* _options;
  std::vector<StructType*> _structs;
  std::vector<EnumType*> _enums;
  std::vector<ExtensionField*> _extensions;
  std::vector<FileDescriptor::Import*> _imports;

  static coda::descriptors::FieldDescriptor Field_name;
  static coda::descriptors::FieldDescriptor Field_directory;
  static coda::descriptors::FieldDescriptor Field_package;
  static coda::descriptors::FieldDescriptor Field_options;
  static coda::descriptors::FieldDescriptor Field_structs;
  static coda::descriptors::FieldDescriptor Field_enums;
  static coda::descriptors::FieldDescriptor Field_extensions;
  static coda::descriptors::FieldDescriptor Field_imports;
  static coda::descriptors::FieldDescriptor* Fields[];
};

extern coda::descriptors::StaticFileDescriptor FILE;

} // namespace coda
} // namespace descriptors

#endif // CODA_RUNTIME_DESCRIPTORS_GENERATED

