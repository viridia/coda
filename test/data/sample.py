# =============================================================================
# Generated by codagen from sample.coda.coda. DO NOT EDIT!
# =============================================================================

import coda.runtime

class E:
  E0 = 0
  E1 = 1
  E2 = 2

  __values__ = (
    'E0', 'E1', 'E2',
  )

# =============================================================================
# S1
# =============================================================================

class S1(coda.runtime.Object):
  __slots__ = [
    '_scalarBoolean',
    '_scalarI16',
    '_scalarI32',
    '_scalarI64',
    '_scalarFixedI16',
    '_scalarFixedI32',
    '_scalarFixedI64',
    '_scalarFloat',
    '_scalarDouble',
    '_scalarString',
    '_scalarBytes',
    '_scalarEnum',
    '_listBoolean',
    '_listInt',
    '_listFloat',
    '_listString',
    '_listEnum',
    '_setInt',
    '_setString',
    '_setEnum',
    '_mapIntString',
    '_mapStringInt',
    '_mapEnumStruct',
    '_unused',
  ]

  __structs__ = ()
  __enums__ = ()
  __fields__ = (
    ('scalarBoolean', 1, 0, -1),
    ('scalarI16', 2, 1, -1),
    ('scalarI32', 3, 2, -1),
    ('scalarI64', 4, 2, -1),
    ('scalarFixedI16', 5, 1, 0),
    ('scalarFixedI32', 6, 2, 0),
    ('scalarFixedI64', 7, 2, 0),
    ('scalarFloat', 8, 3, -1),
    ('scalarDouble', 9, 4, -1),
    ('scalarString', 10, 5, -1),
    ('scalarBytes', 11, 6, -1),
    ('scalarEnum', 12, 22, -1),
    ('listBoolean', 20, 7, -1),
    ('listInt', 21, 8, -1),
    ('listFloat', 22, 9, -1),
    ('listString', 23, 10, -1),
    ('listEnum', 24, 12, -1),
    ('setInt', 41, 13, -1),
    ('setString', 43, 14, -1),
    ('setEnum', 44, 16, -1),
    ('mapIntString', 51, 17, -1),
    ('mapStringInt', 52, 18, -1),
    ('mapEnumStruct', 53, 20, -1),
    ('unused', 100, 2, -1),
  )
  __extensions__ = ()
  TYPE_ID = None

  def __init__(self):
    super().__init__()
    self._scalarBoolean = False
    self._scalarI16 = 0
    self._scalarI32 = 0
    self._scalarI64 = 0
    self._scalarFixedI16 = 0
    self._scalarFixedI32 = 0
    self._scalarFixedI64 = 0
    self._scalarFloat = 0.0
    self._scalarDouble = 0.0
    self._scalarString = coda.runtime.Object.EMPTY_STRING
    self._scalarBytes = coda.runtime.Object.EMPTY_BYTES
    self._scalarEnum = 0
    self._listBoolean = coda.runtime.Object.EMPTY_LIST
    self._listInt = coda.runtime.Object.EMPTY_LIST
    self._listFloat = coda.runtime.Object.EMPTY_LIST
    self._listString = coda.runtime.Object.EMPTY_LIST
    self._listEnum = coda.runtime.Object.EMPTY_LIST
    self._setInt = coda.runtime.Object.EMPTY_SET
    self._setString = coda.runtime.Object.EMPTY_SET
    self._setEnum = coda.runtime.Object.EMPTY_SET
    self._mapIntString = coda.runtime.Object.EMPTY_MAP
    self._mapStringInt = coda.runtime.Object.EMPTY_MAP
    self._mapEnumStruct = coda.runtime.Object.EMPTY_MAP
    self._unused = 0

  def _equalsImpl(self, other):
    return (super()._equalsImpl(other) and
      self._scalarBoolean == other._scalarBoolean and
      self._scalarI16 == other._scalarI16 and
      self._scalarI32 == other._scalarI32 and
      self._scalarI64 == other._scalarI64 and
      self._scalarFixedI16 == other._scalarFixedI16 and
      self._scalarFixedI32 == other._scalarFixedI32 and
      self._scalarFixedI64 == other._scalarFixedI64 and
      self._scalarFloat == other._scalarFloat and
      self._scalarDouble == other._scalarDouble and
      self._scalarString == other._scalarString and
      self._scalarBytes == other._scalarBytes and
      self._scalarEnum == other._scalarEnum and
      self._listBoolean == other._listBoolean and
      self._listInt == other._listInt and
      self._listFloat == other._listFloat and
      self._listString == other._listString and
      self._listEnum == other._listEnum and
      self._setInt == other._setInt and
      self._setString == other._setString and
      self._setEnum == other._setEnum and
      self._mapIntString == other._mapIntString and
      self._mapStringInt == other._mapStringInt and
      self._mapEnumStruct == other._mapEnumStruct and
      self._unused == other._unused)

  def _hashImpl(self):
    return hash((super()._hashImpl(),
      self._scalarBoolean,
      self._scalarI16,
      self._scalarI32,
      self._scalarI64,
      self._scalarFixedI16,
      self._scalarFixedI32,
      self._scalarFixedI64,
      self._scalarFloat,
      self._scalarDouble,
      self._scalarString,
      self._scalarBytes,
      self._scalarEnum,
      self._listBoolean,
      self._listInt,
      self._listFloat,
      self._listString,
      self._listEnum,
      self._setInt,
      self._setString,
      self._setEnum,
      self._mapIntString,
      self._mapStringInt,
      self._mapEnumStruct,
      self._unused))

  def _freezeImpl(self, deep=True):
    super()._freezeImpl(deep)
    if type(self._listBoolean) is not tuple:
      self._listBoolean = tuple(self._listBoolean)
    if type(self._listInt) is not tuple:
      self._listInt = tuple(self._listInt)
    if type(self._listFloat) is not tuple:
      self._listFloat = tuple(self._listFloat)
    if type(self._listString) is not tuple:
      self._listString = tuple(self._listString)
    if type(self._listEnum) is not tuple:
      self._listEnum = tuple(self._listEnum)
    if type(self._setInt) is not frozenset:
      self._setInt = frozenset(self._setInt)
    if type(self._setString) is not frozenset:
      self._setString = frozenset(self._setString)
    if type(self._setEnum) is not frozenset:
      self._setEnum = frozenset(self._setEnum)
    if type(self._mapIntString) is not coda.runtime.FrozenDict:
      self._mapIntString = coda.runtime.FrozenDict(self._mapIntString)
    if type(self._mapStringInt) is not coda.runtime.FrozenDict:
      self._mapStringInt = coda.runtime.FrozenDict(self._mapStringInt)
    if type(self._mapEnumStruct) is not coda.runtime.FrozenDict:
      self._mapEnumStruct = coda.runtime.FrozenDict(self._mapEnumStruct)

  def _writeFields(self, encoder):
    if self.hasScalarBoolean():
      encoder.writeFieldHeader('scalarBoolean', 1)
      encoder.writeBoolean(self._scalarBoolean)
    if self.hasScalarI16():
      encoder.writeFieldHeader('scalarI16', 2)
      encoder.writeInteger(self._scalarI16)
    if self.hasScalarI32():
      encoder.writeFieldHeader('scalarI32', 3)
      encoder.writeInteger(self._scalarI32)
    if self.hasScalarI64():
      encoder.writeFieldHeader('scalarI64', 4)
      encoder.writeInteger(self._scalarI64)
    if self.hasScalarFixedI16():
      encoder.writeFieldHeader('scalarFixedI16', 5)
      encoder.writeFixed16(self._scalarFixedI16)
    if self.hasScalarFixedI32():
      encoder.writeFieldHeader('scalarFixedI32', 6)
      encoder.writeFixed32(self._scalarFixedI32)
    if self.hasScalarFixedI64():
      encoder.writeFieldHeader('scalarFixedI64', 7)
      encoder.writeFixed32(self._scalarFixedI64)
    if self.hasScalarFloat():
      encoder.writeFieldHeader('scalarFloat', 8)
      encoder.writeFloat(self._scalarFloat)
    if self.hasScalarDouble():
      encoder.writeFieldHeader('scalarDouble', 9)
      encoder.writeDouble(self._scalarDouble)
    if self.hasScalarString():
      encoder.writeFieldHeader('scalarString', 10)
      encoder.writeString(self._scalarString)
    if self.hasScalarBytes():
      encoder.writeFieldHeader('scalarBytes', 11)
      encoder.writeBytes(self._scalarBytes)
    if self.hasScalarEnum():
      encoder.writeFieldHeader('scalarEnum', 12)
      encoder.writeInteger(self._scalarEnum)
    if len(self._listBoolean):
      encoder.writeFieldHeader('listBoolean', 20)
      encoder.writeBeginList(1, len(self._listBoolean))
      for val in self._listBoolean:
        encoder.writeBoolean(val)
      encoder.writeEndList()
    if len(self._listInt):
      encoder.writeFieldHeader('listInt', 21)
      encoder.writeBeginList(2, len(self._listInt))
      for val in self._listInt:
        encoder.writeInteger(val)
      encoder.writeEndList()
    if len(self._listFloat):
      encoder.writeFieldHeader('listFloat', 22)
      encoder.writeBeginList(3, len(self._listFloat))
      for val in self._listFloat:
        encoder.writeFloat(val)
      encoder.writeEndList()
    if len(self._listString):
      encoder.writeFieldHeader('listString', 23)
      encoder.writeBeginList(5, len(self._listString))
      for val in self._listString:
        encoder.writeString(val)
      encoder.writeEndList()
    if len(self._listEnum):
      encoder.writeFieldHeader('listEnum', 24)
      encoder.writeBeginList(31, len(self._listEnum))
      for val in self._listEnum:
        encoder.writeInteger(val)
      encoder.writeEndList()
    if len(self._setInt):
      encoder.writeFieldHeader('setInt', 41)
      encoder.writeBeginSet(2, len(self._setInt))
      for val in self._setInt:
        encoder.writeInteger(val)
      encoder.writeEndSet()
    if len(self._setString):
      encoder.writeFieldHeader('setString', 43)
      encoder.writeBeginSet(5, len(self._setString))
      for val in self._setString:
        encoder.writeString(val)
      encoder.writeEndSet()
    if len(self._setEnum):
      encoder.writeFieldHeader('setEnum', 44)
      encoder.writeBeginSet(31, len(self._setEnum))
      for val in self._setEnum:
        encoder.writeInteger(val)
      encoder.writeEndSet()
    if len(self._mapIntString):
      encoder.writeFieldHeader('mapIntString', 51)
      encoder.writeBeginMap(2, 5, len(self._mapIntString))
      for key, val in self._mapIntString.items():
        encoder.writeInteger(key)
        encoder.writeString(val)
      encoder.writeEndMap()
    if len(self._mapStringInt):
      encoder.writeFieldHeader('mapStringInt', 52)
      encoder.writeBeginMap(5, 2, len(self._mapStringInt))
      for key, val in self._mapStringInt.items():
        encoder.writeString(key)
        encoder.writeInteger(val)
      encoder.writeEndMap()
    if len(self._mapEnumStruct):
      encoder.writeFieldHeader('mapEnumStruct', 53)
      encoder.writeBeginMap(31, 30, len(self._mapEnumStruct))
      for key, val in self._mapEnumStruct.items():
        encoder.writeInteger(key)
        encoder.writeStruct(val)
      encoder.writeEndMap()
    if self.hasUnused():
      encoder.writeFieldHeader('unused', 100)
      encoder.writeInteger(self._unused)

  def merge(self, src):
    """@return S1"""
    if src.hasScalarBoolean():
      self.setScalarBoolean(src.isScalarBoolean())
    if src.hasScalarI16():
      self.setScalarI16(src.getScalarI16())
    if src.hasScalarI32():
      self.setScalarI32(src.getScalarI32())
    if src.hasScalarI64():
      self.setScalarI64(src.getScalarI64())
    if src.hasScalarFixedI16():
      self.setScalarFixedI16(src.getScalarFixedI16())
    if src.hasScalarFixedI32():
      self.setScalarFixedI32(src.getScalarFixedI32())
    if src.hasScalarFixedI64():
      self.setScalarFixedI64(src.getScalarFixedI64())
    if src.hasScalarFloat():
      self.setScalarFloat(src.getScalarFloat())
    if src.hasScalarDouble():
      self.setScalarDouble(src.getScalarDouble())
    if src.hasScalarString():
      self.setScalarString(src.getScalarString())
    if src.hasScalarBytes():
      self.setScalarBytes(src.getScalarBytes())
    if src.hasScalarEnum():
      self.setScalarEnum(src.getScalarEnum())
    self.getMutableListBoolean().extend(src.getListBoolean())
    self.getMutableListInt().extend(src.getListInt())
    self.getMutableListFloat().extend(src.getListFloat())
    self.getMutableListString().extend(src.getListString())
    self.getMutableListEnum().extend(src.getListEnum())
    self.getMutableSetInt().update(src.getSetInt())
    self.getMutableSetString().update(src.getSetString())
    self.getMutableSetEnum().update(src.getSetEnum())
    self.getMutableMapIntString().update(src.getMapIntString())
    self.getMutableMapStringInt().update(src.getMapStringInt())
    self.getMutableMapEnumStruct().update(src.getMapEnumStruct())
    if src.hasUnused():
      self.setUnused(src.getUnused())
    return self

  def hasScalarBoolean(self):
    return self._isPresent('scalarBoolean')

  def isScalarBoolean(self):
    return self._scalarBoolean

  def setScalarBoolean(self, scalarBoolean):
    """@return S1"""
    self.checkMutable()
    self._scalarBoolean = scalarBoolean
    self._setPresent('scalarBoolean')
    return self

  def clearScalarBoolean(self):
    """@return S1"""
    self.checkMutable()
    self._scalarBoolean = False
    self._clearPresent('scalarBoolean')
    return self

  def hasScalarI16(self):
    return self._isPresent('scalarI16')

  def getScalarI16(self):
    return self._scalarI16

  def setScalarI16(self, scalarI16):
    """@return S1"""
    self.checkMutable()
    self._scalarI16 = scalarI16
    self._setPresent('scalarI16')
    return self

  def clearScalarI16(self):
    """@return S1"""
    self.checkMutable()
    self._scalarI16 = 0
    self._clearPresent('scalarI16')
    return self

  def hasScalarI32(self):
    return self._isPresent('scalarI32')

  def getScalarI32(self):
    return self._scalarI32

  def setScalarI32(self, scalarI32):
    """@return S1"""
    self.checkMutable()
    self._scalarI32 = scalarI32
    self._setPresent('scalarI32')
    return self

  def clearScalarI32(self):
    """@return S1"""
    self.checkMutable()
    self._scalarI32 = 0
    self._clearPresent('scalarI32')
    return self

  def hasScalarI64(self):
    return self._isPresent('scalarI64')

  def getScalarI64(self):
    return self._scalarI64

  def setScalarI64(self, scalarI64):
    """@return S1"""
    self.checkMutable()
    self._scalarI64 = scalarI64
    self._setPresent('scalarI64')
    return self

  def clearScalarI64(self):
    """@return S1"""
    self.checkMutable()
    self._scalarI64 = 0
    self._clearPresent('scalarI64')
    return self

  def hasScalarFixedI16(self):
    return self._isPresent('scalarFixedI16')

  def getScalarFixedI16(self):
    return self._scalarFixedI16

  def setScalarFixedI16(self, scalarFixedI16):
    """@return S1"""
    self.checkMutable()
    self._scalarFixedI16 = scalarFixedI16
    self._setPresent('scalarFixedI16')
    return self

  def clearScalarFixedI16(self):
    """@return S1"""
    self.checkMutable()
    self._scalarFixedI16 = 0
    self._clearPresent('scalarFixedI16')
    return self

  def hasScalarFixedI32(self):
    return self._isPresent('scalarFixedI32')

  def getScalarFixedI32(self):
    return self._scalarFixedI32

  def setScalarFixedI32(self, scalarFixedI32):
    """@return S1"""
    self.checkMutable()
    self._scalarFixedI32 = scalarFixedI32
    self._setPresent('scalarFixedI32')
    return self

  def clearScalarFixedI32(self):
    """@return S1"""
    self.checkMutable()
    self._scalarFixedI32 = 0
    self._clearPresent('scalarFixedI32')
    return self

  def hasScalarFixedI64(self):
    return self._isPresent('scalarFixedI64')

  def getScalarFixedI64(self):
    return self._scalarFixedI64

  def setScalarFixedI64(self, scalarFixedI64):
    """@return S1"""
    self.checkMutable()
    self._scalarFixedI64 = scalarFixedI64
    self._setPresent('scalarFixedI64')
    return self

  def clearScalarFixedI64(self):
    """@return S1"""
    self.checkMutable()
    self._scalarFixedI64 = 0
    self._clearPresent('scalarFixedI64')
    return self

  def hasScalarFloat(self):
    return self._isPresent('scalarFloat')

  def getScalarFloat(self):
    return self._scalarFloat

  def setScalarFloat(self, scalarFloat):
    """@return S1"""
    self.checkMutable()
    self._scalarFloat = scalarFloat
    self._setPresent('scalarFloat')
    return self

  def clearScalarFloat(self):
    """@return S1"""
    self.checkMutable()
    self._scalarFloat = 0.0
    self._clearPresent('scalarFloat')
    return self

  def hasScalarDouble(self):
    return self._isPresent('scalarDouble')

  def getScalarDouble(self):
    return self._scalarDouble

  def setScalarDouble(self, scalarDouble):
    """@return S1"""
    self.checkMutable()
    self._scalarDouble = scalarDouble
    self._setPresent('scalarDouble')
    return self

  def clearScalarDouble(self):
    """@return S1"""
    self.checkMutable()
    self._scalarDouble = 0.0
    self._clearPresent('scalarDouble')
    return self

  def hasScalarString(self):
    return self._isPresent('scalarString')

  def getScalarString(self):
    return self._scalarString

  def setScalarString(self, scalarString):
    """@return S1"""
    self.checkMutable()
    self._scalarString = scalarString
    self._setPresent('scalarString')
    return self

  def clearScalarString(self):
    """@return S1"""
    self.checkMutable()
    self._scalarString = coda.runtime.Object.EMPTY_STRING
    self._clearPresent('scalarString')
    return self

  def hasScalarBytes(self):
    return self._isPresent('scalarBytes')

  def getScalarBytes(self):
    return self._scalarBytes

  def setScalarBytes(self, scalarBytes):
    """@return S1"""
    self.checkMutable()
    self._scalarBytes = scalarBytes
    self._setPresent('scalarBytes')
    return self

  def clearScalarBytes(self):
    """@return S1"""
    self.checkMutable()
    self._scalarBytes = coda.runtime.Object.EMPTY_BYTES
    self._clearPresent('scalarBytes')
    return self

  def hasScalarEnum(self):
    return self._isPresent('scalarEnum')

  def getScalarEnum(self):
    return self._scalarEnum

  def setScalarEnum(self, scalarEnum):
    """@return S1"""
    self.checkMutable()
    self._scalarEnum = scalarEnum
    self._setPresent('scalarEnum')
    return self

  def clearScalarEnum(self):
    """@return S1"""
    self.checkMutable()
    self._scalarEnum = 0
    self._clearPresent('scalarEnum')
    return self

  def getListBoolean(self):
    return self._listBoolean

  def getMutableListBoolean(self):
    self.checkMutable()
    if self._listBoolean is coda.runtime.Object.EMPTY_LIST:
      self._listBoolean = []
    return self._listBoolean

  def setListBoolean(self, listBoolean):
    """@return S1"""
    self.checkMutable()
    self._listBoolean = listBoolean
    return self

  def clearListBoolean(self):
    """@return S1"""
    self.checkMutable()
    self._listBoolean = coda.runtime.Object.EMPTY_LIST
    return self

  def getListInt(self):
    return self._listInt

  def getMutableListInt(self):
    self.checkMutable()
    if self._listInt is coda.runtime.Object.EMPTY_LIST:
      self._listInt = []
    return self._listInt

  def setListInt(self, listInt):
    """@return S1"""
    self.checkMutable()
    self._listInt = listInt
    return self

  def clearListInt(self):
    """@return S1"""
    self.checkMutable()
    self._listInt = coda.runtime.Object.EMPTY_LIST
    return self

  def getListFloat(self):
    return self._listFloat

  def getMutableListFloat(self):
    self.checkMutable()
    if self._listFloat is coda.runtime.Object.EMPTY_LIST:
      self._listFloat = []
    return self._listFloat

  def setListFloat(self, listFloat):
    """@return S1"""
    self.checkMutable()
    self._listFloat = listFloat
    return self

  def clearListFloat(self):
    """@return S1"""
    self.checkMutable()
    self._listFloat = coda.runtime.Object.EMPTY_LIST
    return self

  def getListString(self):
    return self._listString

  def getMutableListString(self):
    self.checkMutable()
    if self._listString is coda.runtime.Object.EMPTY_LIST:
      self._listString = []
    return self._listString

  def setListString(self, listString):
    """@return S1"""
    self.checkMutable()
    self._listString = listString
    return self

  def clearListString(self):
    """@return S1"""
    self.checkMutable()
    self._listString = coda.runtime.Object.EMPTY_LIST
    return self

  def getListEnum(self):
    return self._listEnum

  def getMutableListEnum(self):
    self.checkMutable()
    if self._listEnum is coda.runtime.Object.EMPTY_LIST:
      self._listEnum = []
    return self._listEnum

  def setListEnum(self, listEnum):
    """@return S1"""
    self.checkMutable()
    self._listEnum = listEnum
    return self

  def clearListEnum(self):
    """@return S1"""
    self.checkMutable()
    self._listEnum = coda.runtime.Object.EMPTY_LIST
    return self

  def getSetInt(self):
    return self._setInt

  def getMutableSetInt(self):
    self.checkMutable()
    if self._setInt is coda.runtime.Object.EMPTY_SET:
      self._setInt = set()
    return self._setInt

  def setSetInt(self, setInt):
    """@return S1"""
    self.checkMutable()
    self._setInt = setInt
    return self

  def clearSetInt(self):
    """@return S1"""
    self.checkMutable()
    self._setInt = coda.runtime.Object.EMPTY_SET
    return self

  def getSetString(self):
    return self._setString

  def getMutableSetString(self):
    self.checkMutable()
    if self._setString is coda.runtime.Object.EMPTY_SET:
      self._setString = set()
    return self._setString

  def setSetString(self, setString):
    """@return S1"""
    self.checkMutable()
    self._setString = setString
    return self

  def clearSetString(self):
    """@return S1"""
    self.checkMutable()
    self._setString = coda.runtime.Object.EMPTY_SET
    return self

  def getSetEnum(self):
    return self._setEnum

  def getMutableSetEnum(self):
    self.checkMutable()
    if self._setEnum is coda.runtime.Object.EMPTY_SET:
      self._setEnum = set()
    return self._setEnum

  def setSetEnum(self, setEnum):
    """@return S1"""
    self.checkMutable()
    self._setEnum = setEnum
    return self

  def clearSetEnum(self):
    """@return S1"""
    self.checkMutable()
    self._setEnum = coda.runtime.Object.EMPTY_SET
    return self

  def getMapIntString(self):
    return self._mapIntString

  def getMutableMapIntString(self):
    self.checkMutable()
    if self._mapIntString is coda.runtime.Object.EMPTY_MAP:
      self._mapIntString = {}
    return self._mapIntString

  def setMapIntString(self, mapIntString):
    """@return S1"""
    self.checkMutable()
    self._mapIntString = mapIntString
    return self

  def clearMapIntString(self):
    """@return S1"""
    self.checkMutable()
    self._mapIntString = coda.runtime.Object.EMPTY_MAP
    return self

  def getMapStringInt(self):
    return self._mapStringInt

  def getMutableMapStringInt(self):
    self.checkMutable()
    if self._mapStringInt is coda.runtime.Object.EMPTY_MAP:
      self._mapStringInt = {}
    return self._mapStringInt

  def setMapStringInt(self, mapStringInt):
    """@return S1"""
    self.checkMutable()
    self._mapStringInt = mapStringInt
    return self

  def clearMapStringInt(self):
    """@return S1"""
    self.checkMutable()
    self._mapStringInt = coda.runtime.Object.EMPTY_MAP
    return self

  def getMapEnumStruct(self):
    return self._mapEnumStruct

  def getMutableMapEnumStruct(self):
    self.checkMutable()
    if self._mapEnumStruct is coda.runtime.Object.EMPTY_MAP:
      self._mapEnumStruct = {}
    return self._mapEnumStruct

  def setMapEnumStruct(self, mapEnumStruct):
    """@return S1"""
    self.checkMutable()
    self._mapEnumStruct = mapEnumStruct
    return self

  def clearMapEnumStruct(self):
    """@return S1"""
    self.checkMutable()
    self._mapEnumStruct = coda.runtime.Object.EMPTY_MAP
    return self

  def hasUnused(self):
    return self._isPresent('unused')

  def getUnused(self):
    return self._unused

  def setUnused(self, unused):
    """@return S1"""
    self.checkMutable()
    self._unused = unused
    self._setPresent('unused')
    return self

  def clearUnused(self):
    """@return S1"""
    self.checkMutable()
    self._unused = 0
    self._clearPresent('unused')
    return self

# =============================================================================
# S2
# =============================================================================

class S2(S1):
  __slots__ = [
    '_left',
    '_right',
  ]

  __structs__ = ()
  __enums__ = ()
  __fields__ = (
    ('left', 1, 21, -1),
    ('right', 2, 21, -1),
  )
  __extensions__ = ()
  TYPE_ID = 1

  def __init__(self):
    super().__init__()
    self._left = S1.defaultInstance()
    self._right = S1.defaultInstance()

  def _equalsImpl(self, other):
    return (super()._equalsImpl(other) and
      self._left == other._left and
      self._right == other._right)

  def _hashImpl(self):
    return hash((super()._hashImpl(),
      self._left,
      self._right))

  def _freezeImpl(self, deep=True):
    super()._freezeImpl(deep)
    if deep and self._left.isMutable():
      self._left.freeze(deep)
    if deep and self._right.isMutable():
      self._right.freeze(deep)

  def _writeFields(self, encoder):
    encoder.writeSubtypeHeader('S2', 1)
    if self.hasLeft():
      encoder.writeFieldHeader('left', 1)
      encoder.writeStruct(self._left)
    if self.hasRight():
      encoder.writeFieldHeader('right', 2)
      encoder.writeStruct(self._right)
    super()._writeFields(encoder)

  def merge(self, src):
    """@return S2"""
    super().merge(src)
    if src.hasLeft():
      self.setLeft(src.getLeft())
    if src.hasRight():
      self.setRight(src.getRight())
    return self

  def hasLeft(self):
    return self._isPresent('left')

  def getLeft(self):
    """@return S1"""
    return self._left

  def getMutableLeft(self):
    """@return S1"""
    self.checkMutable()
    if self._left is S1.defaultInstance() or not self._left.isMutable():
      self._setPresent('left')
      self._left = self._left.shallowCopy()
    return self._left

  def setLeft(self, left):
    """@return S2"""
    self.checkMutable()
    self._left = left
    self._setPresent('left')
    return self

  def clearLeft(self):
    """@return S2"""
    self.checkMutable()
    self._left = S1.defaultInstance()
    self._clearPresent('left')
    return self

  def hasRight(self):
    return self._isPresent('right')

  def getRight(self):
    """@return S1"""
    return self._right

  def getMutableRight(self):
    """@return S1"""
    self.checkMutable()
    if self._right is S1.defaultInstance() or not self._right.isMutable():
      self._setPresent('right')
      self._right = self._right.shallowCopy()
    return self._right

  def setRight(self, right):
    """@return S2"""
    self.checkMutable()
    self._right = right
    self._setPresent('right')
    return self

  def clearRight(self):
    """@return S2"""
    self.checkMutable()
    self._right = S1.defaultInstance()
    self._clearPresent('right')
    return self

# =============================================================================
# S3
# =============================================================================

class S3(S1):
  __slots__ = [
    '_sList',
    '_sSet',
    '_sMap',
  ]

  __structs__ = ()
  __enums__ = ()
  __fields__ = (
    ('sList', 1, 11, -1),
    ('sSet', 2, 15, -1),
    ('sMap', 3, 19, -1),
  )
  __extensions__ = ()
  TYPE_ID = 2

  def __init__(self):
    super().__init__()
    self._sList = coda.runtime.Object.EMPTY_LIST
    self._sSet = coda.runtime.Object.EMPTY_SET
    self._sMap = coda.runtime.Object.EMPTY_MAP

  def _equalsImpl(self, other):
    return (super()._equalsImpl(other) and
      self._sList == other._sList and
      self._sSet == other._sSet and
      self._sMap == other._sMap)

  def _hashImpl(self):
    return hash((super()._hashImpl(),
      self._sList,
      self._sSet,
      self._sMap))

  def _freezeImpl(self, deep=True):
    super()._freezeImpl(deep)
    if type(self._sList) is not tuple:
      self._sList = tuple(self._sList)
    if type(self._sSet) is not frozenset:
      self._sSet = frozenset(self._sSet)
    if type(self._sMap) is not coda.runtime.FrozenDict:
      self._sMap = coda.runtime.FrozenDict(self._sMap)

  def _writeFields(self, encoder):
    encoder.writeSubtypeHeader('S3', 2)
    if len(self._sList):
      encoder.writeFieldHeader('sList', 1)
      encoder.writeBeginList(30, len(self._sList))
      for val in self._sList:
        encoder.writeStruct(val)
      encoder.writeEndList()
    if len(self._sSet):
      encoder.writeFieldHeader('sSet', 2)
      encoder.writeBeginSet(30, len(self._sSet))
      for val in self._sSet:
        encoder.writeStruct(val)
      encoder.writeEndSet()
    if len(self._sMap):
      encoder.writeFieldHeader('sMap', 3)
      encoder.writeBeginMap(5, 30, len(self._sMap))
      for key, val in self._sMap.items():
        encoder.writeString(key)
        encoder.writeStruct(val)
      encoder.writeEndMap()
    super()._writeFields(encoder)

  def merge(self, src):
    """@return S3"""
    super().merge(src)
    self.getMutableSList().extend(src.getSList())
    self.getMutableSSet().update(src.getSSet())
    self.getMutableSMap().update(src.getSMap())
    return self

  def getSList(self):
    return self._sList

  def getMutableSList(self):
    self.checkMutable()
    if self._sList is coda.runtime.Object.EMPTY_LIST:
      self._sList = []
    return self._sList

  def setSList(self, sList):
    """@return S3"""
    self.checkMutable()
    self._sList = sList
    return self

  def clearSList(self):
    """@return S3"""
    self.checkMutable()
    self._sList = coda.runtime.Object.EMPTY_LIST
    return self

  def getSSet(self):
    return self._sSet

  def getMutableSSet(self):
    self.checkMutable()
    if self._sSet is coda.runtime.Object.EMPTY_SET:
      self._sSet = set()
    return self._sSet

  def setSSet(self, sSet):
    """@return S3"""
    self.checkMutable()
    self._sSet = sSet
    return self

  def clearSSet(self):
    """@return S3"""
    self.checkMutable()
    self._sSet = coda.runtime.Object.EMPTY_SET
    return self

  def getSMap(self):
    return self._sMap

  def getMutableSMap(self):
    self.checkMutable()
    if self._sMap is coda.runtime.Object.EMPTY_MAP:
      self._sMap = {}
    return self._sMap

  def setSMap(self, sMap):
    """@return S3"""
    self.checkMutable()
    self._sMap = sMap
    return self

  def clearSMap(self):
    """@return S3"""
    self.checkMutable()
    self._sMap = coda.runtime.Object.EMPTY_MAP
    return self

FILE = coda.runtime.createFile('sample.coda', '/home/talin/Projects/coda/coda/test/data', 'sample',
  structs = (
    S1, S2, S3,
  ),
  enums = (
    E,
  ),
  types = lambda t:(
    t.BOOL,
    t.I16,
    t.I32,
    t.FLOAT,
    t.DOUBLE,
    t.STRING,
    t.BYTES,
    t.ListType().setElementType(t.BOOL),
    t.ListType().setElementType(t.I32),
    t.ListType().setElementType(t.FLOAT),
    t.ListType().setElementType(t.STRING),
    t.ListType().setElementType(S1.DESCRIPTOR),
    t.ListType().setElementType(E.DESCRIPTOR),
    t.SetType().setElementType(t.I32),
    t.SetType().setElementType(t.STRING),
    t.SetType().setElementType(S1.DESCRIPTOR),
    t.SetType().setElementType(E.DESCRIPTOR),
    t.MapType().setKeyType(t.I32).setValueType(t.STRING),
    t.MapType().setKeyType(t.STRING).setValueType(t.I32),
    t.MapType().setKeyType(t.STRING).setValueType(S1.DESCRIPTOR),
    t.MapType().setKeyType(E.DESCRIPTOR).setValueType(S1.DESCRIPTOR),
    S1.DESCRIPTOR,
    E.DESCRIPTOR,
  ),
  options = lambda d:(
    d.FieldOptions().setFixed(True),
    d.FileOptions().setPackage({'cpp': 'sample', 'java': 'sample', 'python': 'sample'}).setOuterClass({'java': 'Sample'})
  ), fileOptions=1, module=globals())

__all__ = [
  'S1', 'S2', 'S3', 'E'
]
