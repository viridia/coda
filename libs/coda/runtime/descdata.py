# =============================================================================
# Generated by codagen from descriptors.coda.coda. DO NOT EDIT!
# =============================================================================

import coda.runtime

class TypeKind:
  TYPE = 0
  BOOL = 1
  INTEGER = 2
  FLOAT = 3
  DOUBLE = 4
  STRING = 5
  BYTES = 6
  LIST = 20
  SET = 21
  MAP = 22
  MODIFIED = 23
  STRUCT = 30
  ENUM = 31
  EXTERN = 32
  COLLECTION = 40
  DECL = 41

  __values__ = (
    'TYPE', 'BOOL', 'INTEGER', 'FLOAT', 'DOUBLE', 'STRING', 'BYTES', 'LIST',
    'SET', 'MAP', 'MODIFIED', 'STRUCT', 'ENUM', 'EXTERN', 'COLLECTION', 'DECL',
  )

# =============================================================================
# Value
# =============================================================================

class Value(coda.runtime.Object):
  __structs__ = ()
  __enums__ = ()
  __fields__ = ()
  __extensions__ = ()
  TYPE_ID = 0

  def __init__(self):
    super().__init__()

  def _writeFields(self, encoder):
    encoder.writeSubtypeHeader('Value', 0)

# =============================================================================
# BoolValue
# =============================================================================

class BoolValue(Value):
  __slots__ = [
    '_value',
  ]

  __structs__ = ()
  __enums__ = ()
  __fields__ = (
    ('value', 1, 0, -1),
  )
  __extensions__ = ()
  TYPE_ID = 1

  def __init__(self):
    super().__init__()
    self._value = False

  def _equalsImpl(self, other):
    return (super()._equalsImpl(other) and
      self._value == other._value)

  def _hashImpl(self):
    return hash((super()._hashImpl(),
      self._value))

  def _writeFields(self, encoder):
    encoder.writeSubtypeHeader('BoolValue', 1)
    if self.hasValue():
      encoder.writeFieldHeader('value', 1)
      encoder.writeBoolean(self._value)
    super()._writeFields(encoder)

  def merge(self, src):
    super().merge(src)
    if src.hasValue():
      self.setValue(src.isValue())
    return self

  def hasValue(self):
    return self._isPresent('value')

  def isValue(self):
    return self._value

  def setValue(self, value):
    self.checkMutable()
    self._value = value
    self._setPresent('value')
    return self

  def clearValue(self):
    self.checkMutable()
    self._value = False
    self._clearPresent('value')
    return self

# =============================================================================
# IntegerValue
# =============================================================================

class IntegerValue(Value):
  __slots__ = [
    '_value',
  ]

  __structs__ = ()
  __enums__ = ()
  __fields__ = (
    ('value', 1, 1, -1),
  )
  __extensions__ = ()
  TYPE_ID = 2

  def __init__(self):
    super().__init__()
    self._value = 0

  def _equalsImpl(self, other):
    return (super()._equalsImpl(other) and
      self._value == other._value)

  def _hashImpl(self):
    return hash((super()._hashImpl(),
      self._value))

  def _writeFields(self, encoder):
    encoder.writeSubtypeHeader('IntegerValue', 2)
    if self.hasValue():
      encoder.writeFieldHeader('value', 1)
      encoder.writeInteger(self._value)
    super()._writeFields(encoder)

  def merge(self, src):
    super().merge(src)
    if src.hasValue():
      self.setValue(src.getValue())
    return self

  def hasValue(self):
    return self._isPresent('value')

  def getValue(self):
    return self._value

  def setValue(self, value):
    self.checkMutable()
    self._value = value
    self._setPresent('value')
    return self

  def clearValue(self):
    self.checkMutable()
    self._value = 0
    self._clearPresent('value')
    return self

# =============================================================================
# StringValue
# =============================================================================

class StringValue(Value):
  __slots__ = [
    '_value',
  ]

  __structs__ = ()
  __enums__ = ()
  __fields__ = (
    ('value', 1, 2, -1),
  )
  __extensions__ = ()
  TYPE_ID = 3

  def __init__(self):
    super().__init__()
    self._value = coda.runtime.Object.EMPTY_STRING

  def _equalsImpl(self, other):
    return (super()._equalsImpl(other) and
      self._value == other._value)

  def _hashImpl(self):
    return hash((super()._hashImpl(),
      self._value))

  def _writeFields(self, encoder):
    encoder.writeSubtypeHeader('StringValue', 3)
    if self.hasValue():
      encoder.writeFieldHeader('value', 1)
      encoder.writeString(self._value)
    super()._writeFields(encoder)

  def merge(self, src):
    super().merge(src)
    if src.hasValue():
      self.setValue(src.getValue())
    return self

  def hasValue(self):
    return self._isPresent('value')

  def getValue(self):
    return self._value

  def setValue(self, value):
    self.checkMutable()
    self._value = value
    self._setPresent('value')
    return self

  def clearValue(self):
    self.checkMutable()
    self._value = coda.runtime.Object.EMPTY_STRING
    self._clearPresent('value')
    return self

# =============================================================================
# ListValue
# =============================================================================

class ListValue(Value):
  __slots__ = [
    '_value',
  ]

  __structs__ = ()
  __enums__ = ()
  __fields__ = (
    ('value', 1, 11, -1),
  )
  __extensions__ = ()
  TYPE_ID = 4

  def __init__(self):
    super().__init__()
    self._value = coda.runtime.Object.EMPTY_LIST

  def _equalsImpl(self, other):
    return (super()._equalsImpl(other) and
      self._value == other._value)

  def _hashImpl(self):
    return hash((super()._hashImpl(),
      self._value))

  def _freezeImpl(self, deep=True):
    super()._freezeImpl(deep)
    if type(self._value) is not tuple:
      self._value = tuple(self._value)

  def _writeFields(self, encoder):
    encoder.writeSubtypeHeader('ListValue', 4)
    if len(self._value):
      encoder.writeFieldHeader('value', 1)
      encoder.writeBeginList(30, len(self._value))
      for val in self._value:
        encoder.writeStruct(val)
      encoder.writeEndList()
    super()._writeFields(encoder)

  def merge(self, src):
    super().merge(src)
    self.getMutableValue().extend(src.getValue())
    return self

  def getValue(self):
    return self._value

  def getMutableValue(self):
    self.checkMutable()
    if self._value is coda.runtime.Object.EMPTY_LIST:
      self._value = []
    return self._value

  def setValue(self, value):
    self.checkMutable()
    self._value = value
    return self

  def clearValue(self):
    self.checkMutable()
    self._value = coda.runtime.Object.EMPTY_LIST
    return self

# =============================================================================
# Options
# =============================================================================

class Options(coda.runtime.Object):
  __structs__ = ()
  __enums__ = ()
  __fields__ = ()
  __extensions__ = ()
  __optionsIndex__ = 2
  TYPE_ID = 0

  def __init__(self):
    super().__init__()

  def _writeFields(self, encoder):
    encoder.writeSubtypeHeader('Options', 0)

# =============================================================================
# FileOptions
# =============================================================================

class FileOptions(Options):
  __slots__ = [
    '_package',
    '_outerClass',
    '_filepath',
    '_imports',
  ]

  __structs__ = ()
  __enums__ = ()
  __fields__ = (
    ('package', 1, 13, -1),
    ('outerClass', 3, 13, -1),
    ('filepath', 4, 13, -1),
    ('imports', 5, 14, -1),
  )
  __extensions__ = ()
  TYPE_ID = 1

  def __init__(self):
    super().__init__()
    self._package = coda.runtime.Object.EMPTY_MAP
    self._outerClass = coda.runtime.Object.EMPTY_MAP
    self._filepath = coda.runtime.Object.EMPTY_MAP
    self._imports = coda.runtime.Object.EMPTY_MAP

  def _equalsImpl(self, other):
    return (super()._equalsImpl(other) and
      self._package == other._package and
      self._outerClass == other._outerClass and
      self._filepath == other._filepath and
      self._imports == other._imports)

  def _hashImpl(self):
    return hash((super()._hashImpl(),
      self._package,
      self._outerClass,
      self._filepath,
      self._imports))

  def _freezeImpl(self, deep=True):
    super()._freezeImpl(deep)
    if type(self._package) is not coda.runtime.FrozenDict:
      self._package = coda.runtime.FrozenDict(self._package)
    if type(self._outerClass) is not coda.runtime.FrozenDict:
      self._outerClass = coda.runtime.FrozenDict(self._outerClass)
    if type(self._filepath) is not coda.runtime.FrozenDict:
      self._filepath = coda.runtime.FrozenDict(self._filepath)
    if type(self._imports) is not coda.runtime.FrozenDict:
      self._imports = coda.runtime.FrozenDict(self._imports)

  def _writeFields(self, encoder):
    encoder.writeSubtypeHeader('FileOptions', 1)
    if len(self._package):
      encoder.writeFieldHeader('package', 1)
      encoder.writeBeginMap(5, 5, len(self._package))
      for key, val in self._package.items():
        encoder.writeString(key)
        encoder.writeString(val)
      encoder.writeEndMap()
    if len(self._outerClass):
      encoder.writeFieldHeader('outerClass', 3)
      encoder.writeBeginMap(5, 5, len(self._outerClass))
      for key, val in self._outerClass.items():
        encoder.writeString(key)
        encoder.writeString(val)
      encoder.writeEndMap()
    if len(self._filepath):
      encoder.writeFieldHeader('filepath', 4)
      encoder.writeBeginMap(5, 5, len(self._filepath))
      for key, val in self._filepath.items():
        encoder.writeString(key)
        encoder.writeString(val)
      encoder.writeEndMap()
    if len(self._imports):
      encoder.writeFieldHeader('imports', 5)
      encoder.writeBeginMap(5, 20, len(self._imports))
      for key, val in self._imports.items():
        encoder.writeString(key)
        encoder.writeBeginList(5, len(val))
        for val in val:
          encoder.writeString(val)
        encoder.writeEndList()
      encoder.writeEndMap()
    super()._writeFields(encoder)

  def merge(self, src):
    super().merge(src)
    self.getMutablePackage().update(src.getPackage())
    self.getMutableOuterClass().update(src.getOuterClass())
    self.getMutableFilepath().update(src.getFilepath())
    self.getMutableImports().update(src.getImports())
    return self

  def getPackage(self):
    return self._package

  def getMutablePackage(self):
    self.checkMutable()
    if self._package is coda.runtime.Object.EMPTY_MAP:
      self._package = {}
    return self._package

  def setPackage(self, package):
    self.checkMutable()
    self._package = package
    return self

  def clearPackage(self):
    self.checkMutable()
    self._package = coda.runtime.Object.EMPTY_MAP
    return self

  def getOuterClass(self):
    return self._outerClass

  def getMutableOuterClass(self):
    self.checkMutable()
    if self._outerClass is coda.runtime.Object.EMPTY_MAP:
      self._outerClass = {}
    return self._outerClass

  def setOuterClass(self, outerClass):
    self.checkMutable()
    self._outerClass = outerClass
    return self

  def clearOuterClass(self):
    self.checkMutable()
    self._outerClass = coda.runtime.Object.EMPTY_MAP
    return self

  def getFilepath(self):
    return self._filepath

  def getMutableFilepath(self):
    self.checkMutable()
    if self._filepath is coda.runtime.Object.EMPTY_MAP:
      self._filepath = {}
    return self._filepath

  def setFilepath(self, filepath):
    self.checkMutable()
    self._filepath = filepath
    return self

  def clearFilepath(self):
    self.checkMutable()
    self._filepath = coda.runtime.Object.EMPTY_MAP
    return self

  def getImports(self):
    return self._imports

  def getMutableImports(self):
    self.checkMutable()
    if self._imports is coda.runtime.Object.EMPTY_MAP:
      self._imports = {}
    return self._imports

  def setImports(self, imports):
    self.checkMutable()
    self._imports = imports
    return self

  def clearImports(self):
    self.checkMutable()
    self._imports = coda.runtime.Object.EMPTY_MAP
    return self

# =============================================================================
# StructOptions
# =============================================================================

class StructOptions(Options):
  __slots__ = [
    '_allowSubtypes',
    '_genClassName',
    '_mixin',
    '_reference',
    '_shared',
  ]

  __structs__ = ()
  __enums__ = ()
  __fields__ = (
    ('allowSubtypes', 1, 0, -1),
    ('genClassName', 2, 13, -1),
    ('mixin', 3, 13, -1),
    ('reference', 4, 0, -1),
    ('shared', 5, 0, -1),
  )
  __extensions__ = ()
  TYPE_ID = 2

  def __init__(self):
    super().__init__()
    self._allowSubtypes = False
    self._genClassName = coda.runtime.Object.EMPTY_MAP
    self._mixin = coda.runtime.Object.EMPTY_MAP
    self._reference = False
    self._shared = False

  def _equalsImpl(self, other):
    return (super()._equalsImpl(other) and
      self._allowSubtypes == other._allowSubtypes and
      self._genClassName == other._genClassName and
      self._mixin == other._mixin and
      self._reference == other._reference and
      self._shared == other._shared)

  def _hashImpl(self):
    return hash((super()._hashImpl(),
      self._allowSubtypes,
      self._genClassName,
      self._mixin,
      self._reference,
      self._shared))

  def _freezeImpl(self, deep=True):
    super()._freezeImpl(deep)
    if type(self._genClassName) is not coda.runtime.FrozenDict:
      self._genClassName = coda.runtime.FrozenDict(self._genClassName)
    if type(self._mixin) is not coda.runtime.FrozenDict:
      self._mixin = coda.runtime.FrozenDict(self._mixin)

  def _writeFields(self, encoder):
    encoder.writeSubtypeHeader('StructOptions', 2)
    if self.hasAllowSubtypes():
      encoder.writeFieldHeader('allowSubtypes', 1)
      encoder.writeBoolean(self._allowSubtypes)
    if len(self._genClassName):
      encoder.writeFieldHeader('genClassName', 2)
      encoder.writeBeginMap(5, 5, len(self._genClassName))
      for key, val in self._genClassName.items():
        encoder.writeString(key)
        encoder.writeString(val)
      encoder.writeEndMap()
    if len(self._mixin):
      encoder.writeFieldHeader('mixin', 3)
      encoder.writeBeginMap(5, 5, len(self._mixin))
      for key, val in self._mixin.items():
        encoder.writeString(key)
        encoder.writeString(val)
      encoder.writeEndMap()
    if self.hasReference():
      encoder.writeFieldHeader('reference', 4)
      encoder.writeBoolean(self._reference)
    if self.hasShared():
      encoder.writeFieldHeader('shared', 5)
      encoder.writeBoolean(self._shared)
    super()._writeFields(encoder)

  def merge(self, src):
    super().merge(src)
    if src.hasAllowSubtypes():
      self.setAllowSubtypes(src.isAllowSubtypes())
    self.getMutableGenClassName().update(src.getGenClassName())
    self.getMutableMixin().update(src.getMixin())
    if src.hasReference():
      self.setReference(src.isReference())
    if src.hasShared():
      self.setShared(src.isShared())
    return self

  def hasAllowSubtypes(self):
    return self._isPresent('allowSubtypes')

  def isAllowSubtypes(self):
    return self._allowSubtypes

  def setAllowSubtypes(self, allowSubtypes):
    self.checkMutable()
    self._allowSubtypes = allowSubtypes
    self._setPresent('allowSubtypes')
    return self

  def clearAllowSubtypes(self):
    self.checkMutable()
    self._allowSubtypes = False
    self._clearPresent('allowSubtypes')
    return self

  def getGenClassName(self):
    return self._genClassName

  def getMutableGenClassName(self):
    self.checkMutable()
    if self._genClassName is coda.runtime.Object.EMPTY_MAP:
      self._genClassName = {}
    return self._genClassName

  def setGenClassName(self, genClassName):
    self.checkMutable()
    self._genClassName = genClassName
    return self

  def clearGenClassName(self):
    self.checkMutable()
    self._genClassName = coda.runtime.Object.EMPTY_MAP
    return self

  def getMixin(self):
    return self._mixin

  def getMutableMixin(self):
    self.checkMutable()
    if self._mixin is coda.runtime.Object.EMPTY_MAP:
      self._mixin = {}
    return self._mixin

  def setMixin(self, mixin):
    self.checkMutable()
    self._mixin = mixin
    return self

  def clearMixin(self):
    self.checkMutable()
    self._mixin = coda.runtime.Object.EMPTY_MAP
    return self

  def hasReference(self):
    return self._isPresent('reference')

  def isReference(self):
    return self._reference

  def setReference(self, reference):
    self.checkMutable()
    self._reference = reference
    self._setPresent('reference')
    return self

  def clearReference(self):
    self.checkMutable()
    self._reference = False
    self._clearPresent('reference')
    return self

  def hasShared(self):
    return self._isPresent('shared')

  def isShared(self):
    return self._shared

  def setShared(self, shared):
    self.checkMutable()
    self._shared = shared
    self._setPresent('shared')
    return self

  def clearShared(self):
    self.checkMutable()
    self._shared = False
    self._clearPresent('shared')
    return self

# =============================================================================
# FieldOptions
# =============================================================================

class FieldOptions(Options):
  __slots__ = [
    '_nullable',
    '_deprecated',
    '_fixed',
    '_transient',
    '_ignore',
    '_default',
    '_novisit',
  ]

  __structs__ = ()
  __enums__ = ()
  __fields__ = (
    ('nullable', 1, 0, -1),
    ('deprecated', 3, 0, -1),
    ('fixed', 4, 0, -1),
    ('transient', 5, 0, -1),
    ('ignore', 6, 12, -1),
    ('default', 7, 24, 0),
    ('novisit', 8, 0, -1),
  )
  __extensions__ = ()
  TYPE_ID = 3

  def __init__(self):
    super().__init__()
    self._nullable = False
    self._deprecated = False
    self._fixed = False
    self._transient = False
    self._ignore = coda.runtime.Object.EMPTY_MAP
    self._default = None
    self._novisit = False

  def _equalsImpl(self, other):
    return (super()._equalsImpl(other) and
      self._nullable == other._nullable and
      self._deprecated == other._deprecated and
      self._fixed == other._fixed and
      self._transient == other._transient and
      self._ignore == other._ignore and
      self._default == other._default and
      self._novisit == other._novisit)

  def _hashImpl(self):
    return hash((super()._hashImpl(),
      self._nullable,
      self._deprecated,
      self._fixed,
      self._transient,
      self._ignore,
      self._default,
      self._novisit))

  def _freezeImpl(self, deep=True):
    super()._freezeImpl(deep)
    if type(self._ignore) is not coda.runtime.FrozenDict:
      self._ignore = coda.runtime.FrozenDict(self._ignore)
    if deep and self._default and self._default.isMutable():
      self._default.freeze(deep)

  def _writeFields(self, encoder):
    encoder.writeSubtypeHeader('FieldOptions', 3)
    if self.hasNullable():
      encoder.writeFieldHeader('nullable', 1)
      encoder.writeBoolean(self._nullable)
    if self.hasDeprecated():
      encoder.writeFieldHeader('deprecated', 3)
      encoder.writeBoolean(self._deprecated)
    if self.hasFixed():
      encoder.writeFieldHeader('fixed', 4)
      encoder.writeBoolean(self._fixed)
    if self.hasTransient():
      encoder.writeFieldHeader('transient', 5)
      encoder.writeBoolean(self._transient)
    if len(self._ignore):
      encoder.writeFieldHeader('ignore', 6)
      encoder.writeBeginMap(5, 1, len(self._ignore))
      for key, val in self._ignore.items():
        encoder.writeString(key)
        encoder.writeBoolean(val)
      encoder.writeEndMap()
    if self.hasDefault():
      encoder.writeFieldHeader('default', 7)
      encoder.writeStruct(self._default)
    if self.hasNovisit():
      encoder.writeFieldHeader('novisit', 8)
      encoder.writeBoolean(self._novisit)
    super()._writeFields(encoder)

  def merge(self, src):
    super().merge(src)
    if src.hasNullable():
      self.setNullable(src.isNullable())
    if src.hasDeprecated():
      self.setDeprecated(src.isDeprecated())
    if src.hasFixed():
      self.setFixed(src.isFixed())
    if src.hasTransient():
      self.setTransient(src.isTransient())
    self.getMutableIgnore().update(src.getIgnore())
    if src.hasDefault():
      self.setDefault(src.getDefault())
    if src.hasNovisit():
      self.setNovisit(src.isNovisit())
    return self

  def hasNullable(self):
    return self._isPresent('nullable')

  def isNullable(self):
    return self._nullable

  def setNullable(self, nullable):
    self.checkMutable()
    self._nullable = nullable
    self._setPresent('nullable')
    return self

  def clearNullable(self):
    self.checkMutable()
    self._nullable = False
    self._clearPresent('nullable')
    return self

  def hasDeprecated(self):
    return self._isPresent('deprecated')

  def isDeprecated(self):
    return self._deprecated

  def setDeprecated(self, deprecated):
    self.checkMutable()
    self._deprecated = deprecated
    self._setPresent('deprecated')
    return self

  def clearDeprecated(self):
    self.checkMutable()
    self._deprecated = False
    self._clearPresent('deprecated')
    return self

  def hasFixed(self):
    return self._isPresent('fixed')

  def isFixed(self):
    return self._fixed

  def setFixed(self, fixed):
    self.checkMutable()
    self._fixed = fixed
    self._setPresent('fixed')
    return self

  def clearFixed(self):
    self.checkMutable()
    self._fixed = False
    self._clearPresent('fixed')
    return self

  def hasTransient(self):
    return self._isPresent('transient')

  def isTransient(self):
    return self._transient

  def setTransient(self, transient):
    self.checkMutable()
    self._transient = transient
    self._setPresent('transient')
    return self

  def clearTransient(self):
    self.checkMutable()
    self._transient = False
    self._clearPresent('transient')
    return self

  def getIgnore(self):
    return self._ignore

  def getMutableIgnore(self):
    self.checkMutable()
    if self._ignore is coda.runtime.Object.EMPTY_MAP:
      self._ignore = {}
    return self._ignore

  def setIgnore(self, ignore):
    self.checkMutable()
    self._ignore = ignore
    return self

  def clearIgnore(self):
    self.checkMutable()
    self._ignore = coda.runtime.Object.EMPTY_MAP
    return self

  def hasDefault(self):
    return self._isPresent('default')

  def getDefault(self):
    return self._default

  def getMutableDefault(self):
    self.checkMutable()
    if self._default is None or not self._default.isMutable():
      self._setPresent('default')
      self._default = self._default.shallowCopy()
    return self._default

  def setDefault(self, default):
    self.checkMutable()
    self._default = default
    self._setPresent('default')
    return self

  def clearDefault(self):
    self.checkMutable()
    self._default = None
    self._clearPresent('default')
    return self

  def hasNovisit(self):
    return self._isPresent('novisit')

  def isNovisit(self):
    return self._novisit

  def setNovisit(self, novisit):
    self.checkMutable()
    self._novisit = novisit
    self._setPresent('novisit')
    return self

  def clearNovisit(self):
    self.checkMutable()
    self._novisit = False
    self._clearPresent('novisit')
    return self

# =============================================================================
# MethodOptions
# =============================================================================

class MethodOptions(Options):
  __slots__ = [
    '_const',
  ]

  __structs__ = ()
  __enums__ = ()
  __fields__ = (
    ('const', 4, 0, -1),
  )
  __extensions__ = ()
  TYPE_ID = 4

  def __init__(self):
    super().__init__()
    self._const = False

  def _equalsImpl(self, other):
    return (super()._equalsImpl(other) and
      self._const == other._const)

  def _hashImpl(self):
    return hash((super()._hashImpl(),
      self._const))

  def _writeFields(self, encoder):
    encoder.writeSubtypeHeader('MethodOptions', 4)
    if self.hasConst():
      encoder.writeFieldHeader('const', 4)
      encoder.writeBoolean(self._const)
    super()._writeFields(encoder)

  def merge(self, src):
    super().merge(src)
    if src.hasConst():
      self.setConst(src.isConst())
    return self

  def hasConst(self):
    return self._isPresent('const')

  def isConst(self):
    return self._const

  def setConst(self, const):
    self.checkMutable()
    self._const = const
    self._setPresent('const')
    return self

  def clearConst(self):
    self.checkMutable()
    self._const = False
    self._clearPresent('const')
    return self

# =============================================================================
# EnumOptions
# =============================================================================

class EnumOptions(Options):
  __structs__ = ()
  __enums__ = ()
  __fields__ = ()
  __extensions__ = ()
  TYPE_ID = 5

  def __init__(self):
    super().__init__()

  def _writeFields(self, encoder):
    encoder.writeSubtypeHeader('EnumOptions', 5)
    super()._writeFields(encoder)

# =============================================================================
# Type
# =============================================================================

class Type(coda.runtime.Object, coda.runtime.typemixins.TypeMixin):
  __structs__ = ()
  __enums__ = ()
  __fields__ = ()
  __extensions__ = ()
  __optionsIndex__ = 4
  TYPE_ID = 0

  def __init__(self):
    super().__init__()

  def _writeFields(self, encoder):
    encoder.writeSubtypeHeader('Type', 0)

# =============================================================================
# BooleanType
# =============================================================================

class BooleanType(Type, coda.runtime.typemixins.BooleanTypeMixin):
  __structs__ = ()
  __enums__ = ()
  __fields__ = ()
  __extensions__ = ()
  __optionsIndex__ = 5
  TYPE_ID = 1

  def __init__(self):
    super().__init__()

  def _writeFields(self, encoder):
    encoder.writeSubtypeHeader('BooleanType', 1)
    super()._writeFields(encoder)

# =============================================================================
# IntegerType
# =============================================================================

class IntegerType(Type, coda.runtime.typemixins.IntegerTypeMixin):
  __slots__ = [
    '_bits',
  ]

  __structs__ = ()
  __enums__ = ()
  __fields__ = (
    ('bits', 1, 1, -1),
  )
  __extensions__ = ()
  __optionsIndex__ = 9
  TYPE_ID = 2

  def __init__(self):
    super().__init__()
    self._bits = 0

  def _equalsImpl(self, other):
    return (super()._equalsImpl(other) and
      self._bits == other._bits)

  def _hashImpl(self):
    return hash((super()._hashImpl(),
      self._bits))

  def _writeFields(self, encoder):
    encoder.writeSubtypeHeader('IntegerType', 2)
    if self.hasBits():
      encoder.writeFieldHeader('bits', 1)
      encoder.writeInteger(self._bits)
    super()._writeFields(encoder)

  def merge(self, src):
    super().merge(src)
    if src.hasBits():
      self.setBits(src.getBits())
    return self

  def hasBits(self):
    return self._isPresent('bits')

  def getBits(self):
    return self._bits

  def setBits(self, bits):
    self.checkMutable()
    self._bits = bits
    self._setPresent('bits')
    return self

  def clearBits(self):
    self.checkMutable()
    self._bits = 0
    self._clearPresent('bits')
    return self

# =============================================================================
# FloatType
# =============================================================================

class FloatType(Type, coda.runtime.typemixins.FloatTypeMixin):
  __structs__ = ()
  __enums__ = ()
  __fields__ = ()
  __extensions__ = ()
  __optionsIndex__ = 8
  TYPE_ID = 3

  def __init__(self):
    super().__init__()

  def _writeFields(self, encoder):
    encoder.writeSubtypeHeader('FloatType', 3)
    super()._writeFields(encoder)

# =============================================================================
# DoubleType
# =============================================================================

class DoubleType(Type, coda.runtime.typemixins.DoubleTypeMixin):
  __structs__ = ()
  __enums__ = ()
  __fields__ = ()
  __extensions__ = ()
  __optionsIndex__ = 7
  TYPE_ID = 4

  def __init__(self):
    super().__init__()

  def _writeFields(self, encoder):
    encoder.writeSubtypeHeader('DoubleType', 4)
    super()._writeFields(encoder)

# =============================================================================
# StringType
# =============================================================================

class StringType(Type, coda.runtime.typemixins.StringTypeMixin):
  __structs__ = ()
  __enums__ = ()
  __fields__ = ()
  __extensions__ = ()
  __optionsIndex__ = 14
  TYPE_ID = 5

  def __init__(self):
    super().__init__()

  def _writeFields(self, encoder):
    encoder.writeSubtypeHeader('StringType', 5)
    super()._writeFields(encoder)

# =============================================================================
# BytesType
# =============================================================================

class BytesType(Type, coda.runtime.typemixins.BytesTypeMixin):
  __structs__ = ()
  __enums__ = ()
  __fields__ = ()
  __extensions__ = ()
  __optionsIndex__ = 6
  TYPE_ID = 6

  def __init__(self):
    super().__init__()

  def _writeFields(self, encoder):
    encoder.writeSubtypeHeader('BytesType', 6)
    super()._writeFields(encoder)

# =============================================================================
# CollectionType
# =============================================================================

class CollectionType(Type):
  __structs__ = ()
  __enums__ = ()
  __fields__ = ()
  __extensions__ = ()
  TYPE_ID = 40

  def __init__(self):
    super().__init__()

  def _writeFields(self, encoder):
    encoder.writeSubtypeHeader('CollectionType', 40)
    super()._writeFields(encoder)

# =============================================================================
# ListType
# =============================================================================

class ListType(CollectionType, coda.runtime.typemixins.ListTypeMixin):
  __slots__ = [
    '_elementType',
  ]

  __structs__ = ()
  __enums__ = ()
  __fields__ = (
    ('elementType', 1, 21, -1),
  )
  __extensions__ = ()
  __optionsIndex__ = 10
  TYPE_ID = 20

  def __init__(self):
    super().__init__()
    self._elementType = Type.defaultInstance()

  def _equalsImpl(self, other):
    return (super()._equalsImpl(other) and
      self._elementType == other._elementType)

  def _hashImpl(self):
    return hash((super()._hashImpl(),
      self._elementType))

  def _freezeImpl(self, deep=True):
    super()._freezeImpl(deep)
    if deep and self._elementType and self._elementType.isMutable():
      self._elementType.freeze(deep)

  def _writeFields(self, encoder):
    encoder.writeSubtypeHeader('ListType', 20)
    if self.hasElementType():
      encoder.writeFieldHeader('elementType', 1)
      encoder.writeStruct(self._elementType, True)
    super()._writeFields(encoder)

  def merge(self, src):
    super().merge(src)
    if src.hasElementType():
      self.setElementType(src.getElementType())
    return self

  def hasElementType(self):
    return self._isPresent('elementType')

  def getElementType(self):
    return self._elementType

  def getMutableElementType(self):
    self.checkMutable()
    if self._elementType is Type.defaultInstance() or not self._elementType.isMutable():
      self._setPresent('elementType')
      self._elementType = self._elementType.shallowCopy()
    return self._elementType

  def setElementType(self, elementType):
    self.checkMutable()
    self._elementType = elementType
    self._setPresent('elementType')
    return self

  def clearElementType(self):
    self.checkMutable()
    self._elementType = Type.defaultInstance()
    self._clearPresent('elementType')
    return self

# =============================================================================
# SetType
# =============================================================================

class SetType(CollectionType, coda.runtime.typemixins.SetTypeMixin):
  __slots__ = [
    '_elementType',
  ]

  __structs__ = ()
  __enums__ = ()
  __fields__ = (
    ('elementType', 1, 21, -1),
  )
  __extensions__ = ()
  __optionsIndex__ = 13
  TYPE_ID = 21

  def __init__(self):
    super().__init__()
    self._elementType = Type.defaultInstance()

  def _equalsImpl(self, other):
    return (super()._equalsImpl(other) and
      self._elementType == other._elementType)

  def _hashImpl(self):
    return hash((super()._hashImpl(),
      self._elementType))

  def _freezeImpl(self, deep=True):
    super()._freezeImpl(deep)
    if deep and self._elementType and self._elementType.isMutable():
      self._elementType.freeze(deep)

  def _writeFields(self, encoder):
    encoder.writeSubtypeHeader('SetType', 21)
    if self.hasElementType():
      encoder.writeFieldHeader('elementType', 1)
      encoder.writeStruct(self._elementType, True)
    super()._writeFields(encoder)

  def merge(self, src):
    super().merge(src)
    if src.hasElementType():
      self.setElementType(src.getElementType())
    return self

  def hasElementType(self):
    return self._isPresent('elementType')

  def getElementType(self):
    return self._elementType

  def getMutableElementType(self):
    self.checkMutable()
    if self._elementType is Type.defaultInstance() or not self._elementType.isMutable():
      self._setPresent('elementType')
      self._elementType = self._elementType.shallowCopy()
    return self._elementType

  def setElementType(self, elementType):
    self.checkMutable()
    self._elementType = elementType
    self._setPresent('elementType')
    return self

  def clearElementType(self):
    self.checkMutable()
    self._elementType = Type.defaultInstance()
    self._clearPresent('elementType')
    return self

# =============================================================================
# MapType
# =============================================================================

class MapType(CollectionType, coda.runtime.typemixins.MapTypeMixin):
  __slots__ = [
    '_keyType',
    '_valueType',
  ]

  __structs__ = ()
  __enums__ = ()
  __fields__ = (
    ('keyType', 1, 21, -1),
    ('valueType', 2, 21, -1),
  )
  __extensions__ = ()
  __optionsIndex__ = 11
  TYPE_ID = 22

  def __init__(self):
    super().__init__()
    self._keyType = Type.defaultInstance()
    self._valueType = Type.defaultInstance()

  def _equalsImpl(self, other):
    return (super()._equalsImpl(other) and
      self._keyType == other._keyType and
      self._valueType == other._valueType)

  def _hashImpl(self):
    return hash((super()._hashImpl(),
      self._keyType,
      self._valueType))

  def _freezeImpl(self, deep=True):
    super()._freezeImpl(deep)
    if deep and self._keyType and self._keyType.isMutable():
      self._keyType.freeze(deep)
    if deep and self._valueType and self._valueType.isMutable():
      self._valueType.freeze(deep)

  def _writeFields(self, encoder):
    encoder.writeSubtypeHeader('MapType', 22)
    if self.hasKeyType():
      encoder.writeFieldHeader('keyType', 1)
      encoder.writeStruct(self._keyType, True)
    if self.hasValueType():
      encoder.writeFieldHeader('valueType', 2)
      encoder.writeStruct(self._valueType, True)
    super()._writeFields(encoder)

  def merge(self, src):
    super().merge(src)
    if src.hasKeyType():
      self.setKeyType(src.getKeyType())
    if src.hasValueType():
      self.setValueType(src.getValueType())
    return self

  def hasKeyType(self):
    return self._isPresent('keyType')

  def getKeyType(self):
    return self._keyType

  def getMutableKeyType(self):
    self.checkMutable()
    if self._keyType is Type.defaultInstance() or not self._keyType.isMutable():
      self._setPresent('keyType')
      self._keyType = self._keyType.shallowCopy()
    return self._keyType

  def setKeyType(self, keyType):
    self.checkMutable()
    self._keyType = keyType
    self._setPresent('keyType')
    return self

  def clearKeyType(self):
    self.checkMutable()
    self._keyType = Type.defaultInstance()
    self._clearPresent('keyType')
    return self

  def hasValueType(self):
    return self._isPresent('valueType')

  def getValueType(self):
    return self._valueType

  def getMutableValueType(self):
    self.checkMutable()
    if self._valueType is Type.defaultInstance() or not self._valueType.isMutable():
      self._setPresent('valueType')
      self._valueType = self._valueType.shallowCopy()
    return self._valueType

  def setValueType(self, valueType):
    self.checkMutable()
    self._valueType = valueType
    self._setPresent('valueType')
    return self

  def clearValueType(self):
    self.checkMutable()
    self._valueType = Type.defaultInstance()
    self._clearPresent('valueType')
    return self

# =============================================================================
# ModifiedType
# =============================================================================

class ModifiedType(Type, coda.runtime.typemixins.ModifiedTypeMixin):
  __slots__ = [
    '_elementType',
    '_const',
    '_shared',
  ]

  __structs__ = ()
  __enums__ = ()
  __fields__ = (
    ('elementType', 1, 21, -1),
    ('const', 2, 0, -1),
    ('shared', 3, 0, -1),
  )
  __extensions__ = ()
  __optionsIndex__ = 12
  TYPE_ID = 23

  def __init__(self):
    super().__init__()
    self._elementType = Type.defaultInstance()
    self._const = False
    self._shared = False

  def _equalsImpl(self, other):
    return (super()._equalsImpl(other) and
      self._elementType == other._elementType and
      self._const == other._const and
      self._shared == other._shared)

  def _hashImpl(self):
    return hash((super()._hashImpl(),
      self._elementType,
      self._const,
      self._shared))

  def _freezeImpl(self, deep=True):
    super()._freezeImpl(deep)
    if deep and self._elementType and self._elementType.isMutable():
      self._elementType.freeze(deep)

  def _writeFields(self, encoder):
    encoder.writeSubtypeHeader('ModifiedType', 23)
    if self.hasElementType():
      encoder.writeFieldHeader('elementType', 1)
      encoder.writeStruct(self._elementType, True)
    if self.hasConst():
      encoder.writeFieldHeader('const', 2)
      encoder.writeBoolean(self._const)
    if self.hasShared():
      encoder.writeFieldHeader('shared', 3)
      encoder.writeBoolean(self._shared)
    super()._writeFields(encoder)

  def merge(self, src):
    super().merge(src)
    if src.hasElementType():
      self.setElementType(src.getElementType())
    if src.hasConst():
      self.setConst(src.isConst())
    if src.hasShared():
      self.setShared(src.isShared())
    return self

  def hasElementType(self):
    return self._isPresent('elementType')

  def getElementType(self):
    return self._elementType

  def getMutableElementType(self):
    self.checkMutable()
    if self._elementType is Type.defaultInstance() or not self._elementType.isMutable():
      self._setPresent('elementType')
      self._elementType = self._elementType.shallowCopy()
    return self._elementType

  def setElementType(self, elementType):
    self.checkMutable()
    self._elementType = elementType
    self._setPresent('elementType')
    return self

  def clearElementType(self):
    self.checkMutable()
    self._elementType = Type.defaultInstance()
    self._clearPresent('elementType')
    return self

  def hasConst(self):
    return self._isPresent('const')

  def isConst(self):
    return self._const

  def setConst(self, const):
    self.checkMutable()
    self._const = const
    self._setPresent('const')
    return self

  def clearConst(self):
    self.checkMutable()
    self._const = False
    self._clearPresent('const')
    return self

  def hasShared(self):
    return self._isPresent('shared')

  def isShared(self):
    return self._shared

  def setShared(self, shared):
    self.checkMutable()
    self._shared = shared
    self._setPresent('shared')
    return self

  def clearShared(self):
    self.checkMutable()
    self._shared = False
    self._clearPresent('shared')
    return self

# =============================================================================
# DeclType
# =============================================================================

class DeclType(Type, coda.runtime.typemixins.DeclTypeMixin):
  __slots__ = [
    '_file',
    '_enclosingType',
    '_name',
    '_sourceLine',
  ]

  __structs__ = ()
  __enums__ = ()
  __fields__ = (
    ('file', 2, 17, 0),
    ('enclosingType', 3, 20, 0),
    ('name', 4, 2, -1),
    ('sourceLine', 5, 1, -1),
  )
  __extensions__ = ()
  __optionsIndex__ = 3
  TYPE_ID = 41

  def __init__(self):
    super().__init__()
    self._file = None
    self._enclosingType = None
    self._name = coda.runtime.Object.EMPTY_STRING
    self._sourceLine = 0

  def _equalsImpl(self, other):
    return (super()._equalsImpl(other) and
      self._file == other._file and
      self._enclosingType == other._enclosingType and
      self._name == other._name and
      self._sourceLine == other._sourceLine)

  def _hashImpl(self):
    return hash((super()._hashImpl(),
      self._file,
      self._enclosingType,
      self._name,
      self._sourceLine))

  def _freezeImpl(self, deep=True):
    super()._freezeImpl(deep)
    if deep and self._file and self._file.isMutable():
      self._file.freeze(deep)
    if deep and self._enclosingType and self._enclosingType.isMutable():
      self._enclosingType.freeze(deep)

  def _writeFields(self, encoder):
    encoder.writeSubtypeHeader('DeclType', 41)
    if self.hasFile():
      encoder.writeFieldHeader('file', 2)
      encoder.writeStruct(self._file, True)
    if self.hasEnclosingType():
      encoder.writeFieldHeader('enclosingType', 3)
      encoder.writeStruct(self._enclosingType, True)
    if self.hasName():
      encoder.writeFieldHeader('name', 4)
      encoder.writeString(self._name)
    if self.hasSourceLine():
      encoder.writeFieldHeader('sourceLine', 5)
      encoder.writeInteger(self._sourceLine)
    super()._writeFields(encoder)

  def merge(self, src):
    super().merge(src)
    if src.hasFile():
      self.setFile(src.getFile())
    if src.hasEnclosingType():
      self.setEnclosingType(src.getEnclosingType())
    if src.hasName():
      self.setName(src.getName())
    if src.hasSourceLine():
      self.setSourceLine(src.getSourceLine())
    return self

  def hasFile(self):
    return self._isPresent('file')

  def getFile(self):
    return self._file

  def getMutableFile(self):
    self.checkMutable()
    if self._file is None or not self._file.isMutable():
      self._setPresent('file')
      self._file = self._file.shallowCopy()
    return self._file

  def setFile(self, file):
    self.checkMutable()
    self._file = file
    self._setPresent('file')
    return self

  def clearFile(self):
    self.checkMutable()
    self._file = None
    self._clearPresent('file')
    return self

  def hasEnclosingType(self):
    return self._isPresent('enclosingType')

  def getEnclosingType(self):
    return self._enclosingType

  def getMutableEnclosingType(self):
    self.checkMutable()
    if self._enclosingType is None or not self._enclosingType.isMutable():
      self._setPresent('enclosingType')
      self._enclosingType = self._enclosingType.shallowCopy()
    return self._enclosingType

  def setEnclosingType(self, enclosingType):
    self.checkMutable()
    self._enclosingType = enclosingType
    self._setPresent('enclosingType')
    return self

  def clearEnclosingType(self):
    self.checkMutable()
    self._enclosingType = None
    self._clearPresent('enclosingType')
    return self

  def hasName(self):
    return self._isPresent('name')

  def getName(self):
    return self._name

  def setName(self, name):
    self.checkMutable()
    self._name = name
    self._setPresent('name')
    return self

  def clearName(self):
    self.checkMutable()
    self._name = coda.runtime.Object.EMPTY_STRING
    self._clearPresent('name')
    return self

  def hasSourceLine(self):
    return self._isPresent('sourceLine')

  def getSourceLine(self):
    return self._sourceLine

  def setSourceLine(self, sourceLine):
    self.checkMutable()
    self._sourceLine = sourceLine
    self._setPresent('sourceLine')
    return self

  def clearSourceLine(self):
    self.checkMutable()
    self._sourceLine = 0
    self._clearPresent('sourceLine')
    return self

# =============================================================================
# StructType
# =============================================================================

class StructType(DeclType):
  __slots__ = [
    '_options',
    '_baseType',
    '_typeId',
    '_fields',
    '_structs',
    '_enums',
    '_extensions',
    '_minExtension',
    '_maxExtension',
  ]

  class Field(coda.runtime.Object):
    __slots__ = [
      '_name',
      '_type',
      '_id',
      '_options',
    ]

    __structs__ = ()
    __enums__ = ()
    __fields__ = (
      ('name', 1, 2, -1),
      ('type', 2, 21, -1),
      ('id', 3, 1, -1),
      ('options', 4, 16, -1),
    )
    __extensions__ = ()
    TYPE_ID = None

    def __init__(self):
      super().__init__()
      self._name = coda.runtime.Object.EMPTY_STRING
      self._type = Type.defaultInstance()
      self._id = 0
      self._options = FieldOptions.defaultInstance()

    def _equalsImpl(self, other):
      return (super()._equalsImpl(other) and
        self._name == other._name and
        self._type == other._type and
        self._id == other._id and
        self._options == other._options)

    def _hashImpl(self):
      return hash((super()._hashImpl(),
        self._name,
        self._type,
        self._id,
        self._options))

    def _freezeImpl(self, deep=True):
      super()._freezeImpl(deep)
      if deep and self._type and self._type.isMutable():
        self._type.freeze(deep)
      if deep and self._options and self._options.isMutable():
        self._options.freeze(deep)

    def _writeFields(self, encoder):
      if self.hasName():
        encoder.writeFieldHeader('name', 1)
        encoder.writeString(self._name)
      if self.hasType():
        encoder.writeFieldHeader('type', 2)
        encoder.writeStruct(self._type, True)
      if self.hasId():
        encoder.writeFieldHeader('id', 3)
        encoder.writeInteger(self._id)
      if self.hasOptions():
        encoder.writeFieldHeader('options', 4)
        encoder.writeStruct(self._options, True)

    def merge(self, src):
      if src.hasName():
        self.setName(src.getName())
      if src.hasType():
        self.setType(src.getType())
      if src.hasId():
        self.setId(src.getId())
      if src.hasOptions():
        self.setOptions(src.getOptions())
      return self

    def hasName(self):
      return self._isPresent('name')

    def getName(self):
      return self._name

    def setName(self, name):
      self.checkMutable()
      self._name = name
      self._setPresent('name')
      return self

    def clearName(self):
      self.checkMutable()
      self._name = coda.runtime.Object.EMPTY_STRING
      self._clearPresent('name')
      return self

    def hasType(self):
      return self._isPresent('type')

    def getType(self):
      return self._type

    def getMutableType(self):
      self.checkMutable()
      if self._type is Type.defaultInstance() or not self._type.isMutable():
        self._setPresent('type')
        self._type = self._type.shallowCopy()
      return self._type

    def setType(self, v_type):
      self.checkMutable()
      self._type = v_type
      self._setPresent('type')
      return self

    def clearType(self):
      self.checkMutable()
      self._type = Type.defaultInstance()
      self._clearPresent('type')
      return self

    def hasId(self):
      return self._isPresent('id')

    def getId(self):
      return self._id

    def setId(self, v_id):
      self.checkMutable()
      self._id = v_id
      self._setPresent('id')
      return self

    def clearId(self):
      self.checkMutable()
      self._id = 0
      self._clearPresent('id')
      return self

    def hasOptions(self):
      return self._isPresent('options')

    def getOptions(self):
      return self._options

    def getMutableOptions(self):
      self.checkMutable()
      if self._options is FieldOptions.defaultInstance() or not self._options.isMutable():
        self._setPresent('options')
        self._options = self._options.shallowCopy()
      return self._options

    def setOptions(self, options):
      self.checkMutable()
      self._options = options
      self._setPresent('options')
      return self

    def clearOptions(self):
      self.checkMutable()
      self._options = FieldOptions.defaultInstance()
      self._clearPresent('options')
      return self

  class Param(coda.runtime.Object):
    __slots__ = [
      '_name',
      '_type',
    ]

    __structs__ = ()
    __enums__ = ()
    __fields__ = (
      ('name', 1, 2, -1),
      ('type', 2, 21, -1),
    )
    __extensions__ = ()
    TYPE_ID = None

    def __init__(self):
      super().__init__()
      self._name = coda.runtime.Object.EMPTY_STRING
      self._type = Type.defaultInstance()

    def _equalsImpl(self, other):
      return (super()._equalsImpl(other) and
        self._name == other._name and
        self._type == other._type)

    def _hashImpl(self):
      return hash((super()._hashImpl(),
        self._name,
        self._type))

    def _freezeImpl(self, deep=True):
      super()._freezeImpl(deep)
      if deep and self._type and self._type.isMutable():
        self._type.freeze(deep)

    def _writeFields(self, encoder):
      if self.hasName():
        encoder.writeFieldHeader('name', 1)
        encoder.writeString(self._name)
      if self.hasType():
        encoder.writeFieldHeader('type', 2)
        encoder.writeStruct(self._type, True)

    def merge(self, src):
      if src.hasName():
        self.setName(src.getName())
      if src.hasType():
        self.setType(src.getType())
      return self

    def hasName(self):
      return self._isPresent('name')

    def getName(self):
      return self._name

    def setName(self, name):
      self.checkMutable()
      self._name = name
      self._setPresent('name')
      return self

    def clearName(self):
      self.checkMutable()
      self._name = coda.runtime.Object.EMPTY_STRING
      self._clearPresent('name')
      return self

    def hasType(self):
      return self._isPresent('type')

    def getType(self):
      return self._type

    def getMutableType(self):
      self.checkMutable()
      if self._type is Type.defaultInstance() or not self._type.isMutable():
        self._setPresent('type')
        self._type = self._type.shallowCopy()
      return self._type

    def setType(self, v_type):
      self.checkMutable()
      self._type = v_type
      self._setPresent('type')
      return self

    def clearType(self):
      self.checkMutable()
      self._type = Type.defaultInstance()
      self._clearPresent('type')
      return self

  class Method(coda.runtime.Object):
    __slots__ = [
      '_name',
      '_params',
      '_returnType',
      '_id',
      '_options',
    ]

    __structs__ = ()
    __enums__ = ()
    __fields__ = (
      ('name', 1, 2, -1),
      ('params', 2, 10, -1),
      ('returnType', 3, 21, -1),
      ('id', 4, 1, -1),
      ('options', 5, 18, -1),
    )
    __extensions__ = ()
    TYPE_ID = None

    def __init__(self):
      super().__init__()
      self._name = coda.runtime.Object.EMPTY_STRING
      self._params = coda.runtime.Object.EMPTY_LIST
      self._returnType = Type.defaultInstance()
      self._id = 0
      self._options = MethodOptions.defaultInstance()

    def _equalsImpl(self, other):
      return (super()._equalsImpl(other) and
        self._name == other._name and
        self._params == other._params and
        self._returnType == other._returnType and
        self._id == other._id and
        self._options == other._options)

    def _hashImpl(self):
      return hash((super()._hashImpl(),
        self._name,
        self._params,
        self._returnType,
        self._id,
        self._options))

    def _freezeImpl(self, deep=True):
      super()._freezeImpl(deep)
      if type(self._params) is not tuple:
        self._params = tuple(self._params)
      if deep and self._returnType and self._returnType.isMutable():
        self._returnType.freeze(deep)
      if deep and self._options and self._options.isMutable():
        self._options.freeze(deep)

    def _writeFields(self, encoder):
      if self.hasName():
        encoder.writeFieldHeader('name', 1)
        encoder.writeString(self._name)
      if len(self._params):
        encoder.writeFieldHeader('params', 2)
        encoder.writeBeginList(30, len(self._params))
        for val in self._params:
          encoder.writeStruct(val)
        encoder.writeEndList()
      if self.hasReturnType():
        encoder.writeFieldHeader('returnType', 3)
        encoder.writeStruct(self._returnType, True)
      if self.hasId():
        encoder.writeFieldHeader('id', 4)
        encoder.writeInteger(self._id)
      if self.hasOptions():
        encoder.writeFieldHeader('options', 5)
        encoder.writeStruct(self._options, True)

    def merge(self, src):
      if src.hasName():
        self.setName(src.getName())
      self.getMutableParams().extend(src.getParams())
      if src.hasReturnType():
        self.setReturnType(src.getReturnType())
      if src.hasId():
        self.setId(src.getId())
      if src.hasOptions():
        self.setOptions(src.getOptions())
      return self

    def hasName(self):
      return self._isPresent('name')

    def getName(self):
      return self._name

    def setName(self, name):
      self.checkMutable()
      self._name = name
      self._setPresent('name')
      return self

    def clearName(self):
      self.checkMutable()
      self._name = coda.runtime.Object.EMPTY_STRING
      self._clearPresent('name')
      return self

    def getParams(self):
      return self._params

    def getMutableParams(self):
      self.checkMutable()
      if self._params is coda.runtime.Object.EMPTY_LIST:
        self._params = []
      return self._params

    def setParams(self, params):
      self.checkMutable()
      self._params = params
      return self

    def clearParams(self):
      self.checkMutable()
      self._params = coda.runtime.Object.EMPTY_LIST
      return self

    def hasReturnType(self):
      return self._isPresent('returnType')

    def getReturnType(self):
      return self._returnType

    def getMutableReturnType(self):
      self.checkMutable()
      if self._returnType is Type.defaultInstance() or not self._returnType.isMutable():
        self._setPresent('returnType')
        self._returnType = self._returnType.shallowCopy()
      return self._returnType

    def setReturnType(self, returnType):
      self.checkMutable()
      self._returnType = returnType
      self._setPresent('returnType')
      return self

    def clearReturnType(self):
      self.checkMutable()
      self._returnType = Type.defaultInstance()
      self._clearPresent('returnType')
      return self

    def hasId(self):
      return self._isPresent('id')

    def getId(self):
      return self._id

    def setId(self, v_id):
      self.checkMutable()
      self._id = v_id
      self._setPresent('id')
      return self

    def clearId(self):
      self.checkMutable()
      self._id = 0
      self._clearPresent('id')
      return self

    def hasOptions(self):
      return self._isPresent('options')

    def getOptions(self):
      return self._options

    def getMutableOptions(self):
      self.checkMutable()
      if self._options is MethodOptions.defaultInstance() or not self._options.isMutable():
        self._setPresent('options')
        self._options = self._options.shallowCopy()
      return self._options

    def setOptions(self, options):
      self.checkMutable()
      self._options = options
      self._setPresent('options')
      return self

    def clearOptions(self):
      self.checkMutable()
      self._options = MethodOptions.defaultInstance()
      self._clearPresent('options')
      return self

  __structs__ = (
    Field,
    Param,
    Method,
  )
  __enums__ = ()
  __fields__ = (
    ('options', 1, 19, -1),
    ('baseType', 3, 20, 0),
    ('typeId', 4, 1, -1),
    ('fields', 5, 9, -1),
    ('structs', 6, 5, -1),
    ('enums', 7, 3, -1),
    ('extensions', 8, 7, -1),
    ('minExtension', 9, 1, -1),
    ('maxExtension', 10, 1, -1),
  )
  __extensions__ = ()
  TYPE_ID = 30

  def __init__(self):
    super().__init__()
    self._options = StructOptions.defaultInstance()
    self._baseType = None
    self._typeId = 0
    self._fields = coda.runtime.Object.EMPTY_LIST
    self._structs = coda.runtime.Object.EMPTY_LIST
    self._enums = coda.runtime.Object.EMPTY_LIST
    self._extensions = coda.runtime.Object.EMPTY_LIST
    self._minExtension = 0
    self._maxExtension = 0

  def _equalsImpl(self, other):
    return (super()._equalsImpl(other) and
      self._options == other._options and
      self._baseType == other._baseType and
      self._typeId == other._typeId and
      self._fields == other._fields and
      self._structs == other._structs and
      self._enums == other._enums and
      self._extensions == other._extensions and
      self._minExtension == other._minExtension and
      self._maxExtension == other._maxExtension)

  def _hashImpl(self):
    return hash((super()._hashImpl(),
      self._options,
      self._baseType,
      self._typeId,
      self._fields,
      self._structs,
      self._enums,
      self._extensions,
      self._minExtension,
      self._maxExtension))

  def _freezeImpl(self, deep=True):
    super()._freezeImpl(deep)
    if deep and self._options and self._options.isMutable():
      self._options.freeze(deep)
    if deep and self._baseType and self._baseType.isMutable():
      self._baseType.freeze(deep)
    if type(self._fields) is not tuple:
      self._fields = tuple(self._fields)
    if type(self._structs) is not tuple:
      self._structs = tuple(self._structs)
    if type(self._enums) is not tuple:
      self._enums = tuple(self._enums)
    if type(self._extensions) is not tuple:
      self._extensions = tuple(self._extensions)

  def _writeFields(self, encoder):
    encoder.writeSubtypeHeader('StructType', 30)
    if self.hasOptions():
      encoder.writeFieldHeader('options', 1)
      encoder.writeStruct(self._options, True)
    if self.hasBaseType():
      encoder.writeFieldHeader('baseType', 3)
      encoder.writeStruct(self._baseType, True)
    if self.hasTypeId():
      encoder.writeFieldHeader('typeId', 4)
      encoder.writeInteger(self._typeId)
    if len(self._fields):
      encoder.writeFieldHeader('fields', 5)
      encoder.writeBeginList(30, len(self._fields))
      for val in self._fields:
        encoder.writeStruct(val)
      encoder.writeEndList()
    if len(self._structs):
      encoder.writeFieldHeader('structs', 6)
      encoder.writeBeginList(30, len(self._structs))
      for val in self._structs:
        encoder.writeStruct(val, True)
      encoder.writeEndList()
    if len(self._enums):
      encoder.writeFieldHeader('enums', 7)
      encoder.writeBeginList(30, len(self._enums))
      for val in self._enums:
        encoder.writeStruct(val, True)
      encoder.writeEndList()
    if len(self._extensions):
      encoder.writeFieldHeader('extensions', 8)
      encoder.writeBeginList(30, len(self._extensions))
      for val in self._extensions:
        encoder.writeStruct(val)
      encoder.writeEndList()
    if self.hasMinExtension():
      encoder.writeFieldHeader('minExtension', 9)
      encoder.writeInteger(self._minExtension)
    if self.hasMaxExtension():
      encoder.writeFieldHeader('maxExtension', 10)
      encoder.writeInteger(self._maxExtension)
    super()._writeFields(encoder)

  def merge(self, src):
    super().merge(src)
    if src.hasOptions():
      self.setOptions(src.getOptions())
    if src.hasBaseType():
      self.setBaseType(src.getBaseType())
    if src.hasTypeId():
      self.setTypeId(src.getTypeId())
    self.getMutableFields().extend(src.getFields())
    self.getMutableStructs().extend(src.getStructs())
    self.getMutableEnums().extend(src.getEnums())
    self.getMutableExtensions().extend(src.getExtensions())
    if src.hasMinExtension():
      self.setMinExtension(src.getMinExtension())
    if src.hasMaxExtension():
      self.setMaxExtension(src.getMaxExtension())
    return self

  def hasOptions(self):
    return self._isPresent('options')

  def getOptions(self):
    return self._options

  def getMutableOptions(self):
    self.checkMutable()
    if self._options is StructOptions.defaultInstance() or not self._options.isMutable():
      self._setPresent('options')
      self._options = self._options.shallowCopy()
    return self._options

  def setOptions(self, options):
    self.checkMutable()
    self._options = options
    self._setPresent('options')
    return self

  def clearOptions(self):
    self.checkMutable()
    self._options = StructOptions.defaultInstance()
    self._clearPresent('options')
    return self

  def hasBaseType(self):
    return self._isPresent('baseType')

  def getBaseType(self):
    return self._baseType

  def getMutableBaseType(self):
    self.checkMutable()
    if self._baseType is None or not self._baseType.isMutable():
      self._setPresent('baseType')
      self._baseType = self._baseType.shallowCopy()
    return self._baseType

  def setBaseType(self, baseType):
    self.checkMutable()
    self._baseType = baseType
    self._setPresent('baseType')
    return self

  def clearBaseType(self):
    self.checkMutable()
    self._baseType = None
    self._clearPresent('baseType')
    return self

  def hasTypeId(self):
    return self._isPresent('typeId')

  def getTypeId(self):
    return self._typeId

  def setTypeId(self, typeId):
    self.checkMutable()
    self._typeId = typeId
    self._setPresent('typeId')
    return self

  def clearTypeId(self):
    self.checkMutable()
    self._typeId = 0
    self._clearPresent('typeId')
    return self

  def getFields(self):
    return self._fields

  def getMutableFields(self):
    self.checkMutable()
    if self._fields is coda.runtime.Object.EMPTY_LIST:
      self._fields = []
    return self._fields

  def setFields(self, fields):
    self.checkMutable()
    self._fields = fields
    return self

  def clearFields(self):
    self.checkMutable()
    self._fields = coda.runtime.Object.EMPTY_LIST
    return self

  def getStructs(self):
    return self._structs

  def getMutableStructs(self):
    self.checkMutable()
    if self._structs is coda.runtime.Object.EMPTY_LIST:
      self._structs = []
    return self._structs

  def setStructs(self, structs):
    self.checkMutable()
    self._structs = structs
    return self

  def clearStructs(self):
    self.checkMutable()
    self._structs = coda.runtime.Object.EMPTY_LIST
    return self

  def getEnums(self):
    return self._enums

  def getMutableEnums(self):
    self.checkMutable()
    if self._enums is coda.runtime.Object.EMPTY_LIST:
      self._enums = []
    return self._enums

  def setEnums(self, enums):
    self.checkMutable()
    self._enums = enums
    return self

  def clearEnums(self):
    self.checkMutable()
    self._enums = coda.runtime.Object.EMPTY_LIST
    return self

  def getExtensions(self):
    return self._extensions

  def getMutableExtensions(self):
    self.checkMutable()
    if self._extensions is coda.runtime.Object.EMPTY_LIST:
      self._extensions = []
    return self._extensions

  def setExtensions(self, extensions):
    self.checkMutable()
    self._extensions = extensions
    return self

  def clearExtensions(self):
    self.checkMutable()
    self._extensions = coda.runtime.Object.EMPTY_LIST
    return self

  def hasMinExtension(self):
    return self._isPresent('minExtension')

  def getMinExtension(self):
    return self._minExtension

  def setMinExtension(self, minExtension):
    self.checkMutable()
    self._minExtension = minExtension
    self._setPresent('minExtension')
    return self

  def clearMinExtension(self):
    self.checkMutable()
    self._minExtension = 0
    self._clearPresent('minExtension')
    return self

  def hasMaxExtension(self):
    return self._isPresent('maxExtension')

  def getMaxExtension(self):
    return self._maxExtension

  def setMaxExtension(self, maxExtension):
    self.checkMutable()
    self._maxExtension = maxExtension
    self._setPresent('maxExtension')
    return self

  def clearMaxExtension(self):
    self.checkMutable()
    self._maxExtension = 0
    self._clearPresent('maxExtension')
    return self

# =============================================================================
# EnumType
# =============================================================================

class EnumType(DeclType):
  __slots__ = [
    '_options',
    '_values',
  ]

  class Value(coda.runtime.Object):
    __slots__ = [
      '_name',
      '_value',
    ]

    __structs__ = ()
    __enums__ = ()
    __fields__ = (
      ('name', 1, 2, -1),
      ('value', 2, 1, -1),
    )
    __extensions__ = ()
    TYPE_ID = None

    def __init__(self):
      super().__init__()
      self._name = coda.runtime.Object.EMPTY_STRING
      self._value = 0

    def _equalsImpl(self, other):
      return (super()._equalsImpl(other) and
        self._name == other._name and
        self._value == other._value)

    def _hashImpl(self):
      return hash((super()._hashImpl(),
        self._name,
        self._value))

    def _writeFields(self, encoder):
      if self.hasName():
        encoder.writeFieldHeader('name', 1)
        encoder.writeString(self._name)
      if self.hasValue():
        encoder.writeFieldHeader('value', 2)
        encoder.writeInteger(self._value)

    def merge(self, src):
      if src.hasName():
        self.setName(src.getName())
      if src.hasValue():
        self.setValue(src.getValue())
      return self

    def hasName(self):
      return self._isPresent('name')

    def getName(self):
      return self._name

    def setName(self, name):
      self.checkMutable()
      self._name = name
      self._setPresent('name')
      return self

    def clearName(self):
      self.checkMutable()
      self._name = coda.runtime.Object.EMPTY_STRING
      self._clearPresent('name')
      return self

    def hasValue(self):
      return self._isPresent('value')

    def getValue(self):
      return self._value

    def setValue(self, value):
      self.checkMutable()
      self._value = value
      self._setPresent('value')
      return self

    def clearValue(self):
      self.checkMutable()
      self._value = 0
      self._clearPresent('value')
      return self

  __structs__ = (
    Value,
  )
  __enums__ = ()
  __fields__ = (
    ('options', 1, 15, -1),
    ('values', 2, 6, -1),
  )
  __extensions__ = ()
  TYPE_ID = 31

  def __init__(self):
    super().__init__()
    self._options = EnumOptions.defaultInstance()
    self._values = coda.runtime.Object.EMPTY_LIST

  def _equalsImpl(self, other):
    return (super()._equalsImpl(other) and
      self._options == other._options and
      self._values == other._values)

  def _hashImpl(self):
    return hash((super()._hashImpl(),
      self._options,
      self._values))

  def _freezeImpl(self, deep=True):
    super()._freezeImpl(deep)
    if deep and self._options and self._options.isMutable():
      self._options.freeze(deep)
    if type(self._values) is not tuple:
      self._values = tuple(self._values)

  def _writeFields(self, encoder):
    encoder.writeSubtypeHeader('EnumType', 31)
    if self.hasOptions():
      encoder.writeFieldHeader('options', 1)
      encoder.writeStruct(self._options, True)
    if len(self._values):
      encoder.writeFieldHeader('values', 2)
      encoder.writeBeginList(30, len(self._values))
      for val in self._values:
        encoder.writeStruct(val)
      encoder.writeEndList()
    super()._writeFields(encoder)

  def merge(self, src):
    super().merge(src)
    if src.hasOptions():
      self.setOptions(src.getOptions())
    self.getMutableValues().extend(src.getValues())
    return self

  def hasOptions(self):
    return self._isPresent('options')

  def getOptions(self):
    return self._options

  def getMutableOptions(self):
    self.checkMutable()
    if self._options is EnumOptions.defaultInstance() or not self._options.isMutable():
      self._setPresent('options')
      self._options = self._options.shallowCopy()
    return self._options

  def setOptions(self, options):
    self.checkMutable()
    self._options = options
    self._setPresent('options')
    return self

  def clearOptions(self):
    self.checkMutable()
    self._options = EnumOptions.defaultInstance()
    self._clearPresent('options')
    return self

  def getValues(self):
    return self._values

  def getMutableValues(self):
    self.checkMutable()
    if self._values is coda.runtime.Object.EMPTY_LIST:
      self._values = []
    return self._values

  def setValues(self, values):
    self.checkMutable()
    self._values = values
    return self

  def clearValues(self):
    self.checkMutable()
    self._values = coda.runtime.Object.EMPTY_LIST
    return self

# =============================================================================
# ExtensionField
# =============================================================================

class ExtensionField(coda.runtime.Object):
  __slots__ = [
    '_file',
    '_enclosingType',
    '_sourceLine',
    '_extends',
    '_name',
    '_id',
    '_type',
  ]

  __structs__ = ()
  __enums__ = ()
  __fields__ = (
    ('file', 1, 17, 0),
    ('enclosingType', 2, 23, -1),
    ('sourceLine', 3, 1, -1),
    ('extends', 4, 20, -1),
    ('name', 5, 2, -1),
    ('id', 6, 1, -1),
    ('type', 7, 21, -1),
  )
  __extensions__ = ()
  TYPE_ID = None

  def __init__(self):
    super().__init__()
    self._file = None
    self._enclosingType = StructType.defaultInstance()
    self._sourceLine = 0
    self._extends = StructType.defaultInstance()
    self._name = coda.runtime.Object.EMPTY_STRING
    self._id = 0
    self._type = Type.defaultInstance()

  def _equalsImpl(self, other):
    return (super()._equalsImpl(other) and
      self._file == other._file and
      self._enclosingType == other._enclosingType and
      self._sourceLine == other._sourceLine and
      self._extends == other._extends and
      self._name == other._name and
      self._id == other._id and
      self._type == other._type)

  def _hashImpl(self):
    return hash((super()._hashImpl(),
      self._file,
      self._enclosingType,
      self._sourceLine,
      self._extends,
      self._name,
      self._id,
      self._type))

  def _freezeImpl(self, deep=True):
    super()._freezeImpl(deep)
    if deep and self._file and self._file.isMutable():
      self._file.freeze(deep)
    if deep and self._enclosingType and self._enclosingType.isMutable():
      self._enclosingType.freeze(deep)
    if deep and self._extends and self._extends.isMutable():
      self._extends.freeze(deep)
    if deep and self._type and self._type.isMutable():
      self._type.freeze(deep)

  def _writeFields(self, encoder):
    if self.hasFile():
      encoder.writeFieldHeader('file', 1)
      encoder.writeStruct(self._file, True)
    if self.hasEnclosingType():
      encoder.writeFieldHeader('enclosingType', 2)
      encoder.writeStruct(self._enclosingType, True)
    if self.hasSourceLine():
      encoder.writeFieldHeader('sourceLine', 3)
      encoder.writeInteger(self._sourceLine)
    if self.hasExtends():
      encoder.writeFieldHeader('extends', 4)
      encoder.writeStruct(self._extends, True)
    if self.hasName():
      encoder.writeFieldHeader('name', 5)
      encoder.writeString(self._name)
    if self.hasId():
      encoder.writeFieldHeader('id', 6)
      encoder.writeInteger(self._id)
    if self.hasType():
      encoder.writeFieldHeader('type', 7)
      encoder.writeStruct(self._type, True)

  def merge(self, src):
    if src.hasFile():
      self.setFile(src.getFile())
    if src.hasEnclosingType():
      self.setEnclosingType(src.getEnclosingType())
    if src.hasSourceLine():
      self.setSourceLine(src.getSourceLine())
    if src.hasExtends():
      self.setExtends(src.getExtends())
    if src.hasName():
      self.setName(src.getName())
    if src.hasId():
      self.setId(src.getId())
    if src.hasType():
      self.setType(src.getType())
    return self

  def hasFile(self):
    return self._isPresent('file')

  def getFile(self):
    return self._file

  def getMutableFile(self):
    self.checkMutable()
    if self._file is None or not self._file.isMutable():
      self._setPresent('file')
      self._file = self._file.shallowCopy()
    return self._file

  def setFile(self, file):
    self.checkMutable()
    self._file = file
    self._setPresent('file')
    return self

  def clearFile(self):
    self.checkMutable()
    self._file = None
    self._clearPresent('file')
    return self

  def hasEnclosingType(self):
    return self._isPresent('enclosingType')

  def getEnclosingType(self):
    return self._enclosingType

  def getMutableEnclosingType(self):
    self.checkMutable()
    if self._enclosingType is StructType.defaultInstance() or not self._enclosingType.isMutable():
      self._setPresent('enclosingType')
      self._enclosingType = self._enclosingType.shallowCopy()
    return self._enclosingType

  def setEnclosingType(self, enclosingType):
    self.checkMutable()
    self._enclosingType = enclosingType
    self._setPresent('enclosingType')
    return self

  def clearEnclosingType(self):
    self.checkMutable()
    self._enclosingType = StructType.defaultInstance()
    self._clearPresent('enclosingType')
    return self

  def hasSourceLine(self):
    return self._isPresent('sourceLine')

  def getSourceLine(self):
    return self._sourceLine

  def setSourceLine(self, sourceLine):
    self.checkMutable()
    self._sourceLine = sourceLine
    self._setPresent('sourceLine')
    return self

  def clearSourceLine(self):
    self.checkMutable()
    self._sourceLine = 0
    self._clearPresent('sourceLine')
    return self

  def hasExtends(self):
    return self._isPresent('extends')

  def getExtends(self):
    return self._extends

  def getMutableExtends(self):
    self.checkMutable()
    if self._extends is StructType.defaultInstance() or not self._extends.isMutable():
      self._setPresent('extends')
      self._extends = self._extends.shallowCopy()
    return self._extends

  def setExtends(self, extends):
    self.checkMutable()
    self._extends = extends
    self._setPresent('extends')
    return self

  def clearExtends(self):
    self.checkMutable()
    self._extends = StructType.defaultInstance()
    self._clearPresent('extends')
    return self

  def hasName(self):
    return self._isPresent('name')

  def getName(self):
    return self._name

  def setName(self, name):
    self.checkMutable()
    self._name = name
    self._setPresent('name')
    return self

  def clearName(self):
    self.checkMutable()
    self._name = coda.runtime.Object.EMPTY_STRING
    self._clearPresent('name')
    return self

  def hasId(self):
    return self._isPresent('id')

  def getId(self):
    return self._id

  def setId(self, v_id):
    self.checkMutable()
    self._id = v_id
    self._setPresent('id')
    return self

  def clearId(self):
    self.checkMutable()
    self._id = 0
    self._clearPresent('id')
    return self

  def hasType(self):
    return self._isPresent('type')

  def getType(self):
    return self._type

  def getMutableType(self):
    self.checkMutable()
    if self._type is Type.defaultInstance() or not self._type.isMutable():
      self._setPresent('type')
      self._type = self._type.shallowCopy()
    return self._type

  def setType(self, v_type):
    self.checkMutable()
    self._type = v_type
    self._setPresent('type')
    return self

  def clearType(self):
    self.checkMutable()
    self._type = Type.defaultInstance()
    self._clearPresent('type')
    return self

# =============================================================================
# FileDescriptor
# =============================================================================

class FileDescriptor(coda.runtime.Object):
  __slots__ = [
    '_name',
    '_directory',
    '_package',
    '_options',
    '_structs',
    '_enums',
    '_extensions',
    '_imports',
  ]

  class Import(coda.runtime.Object):
    __slots__ = [
      '_path',
      '_package',
    ]

    __structs__ = ()
    __enums__ = ()
    __fields__ = (
      ('path', 1, 2, -1),
      ('package', 2, 13, -1),
    )
    __extensions__ = ()
    TYPE_ID = None

    def __init__(self):
      super().__init__()
      self._path = coda.runtime.Object.EMPTY_STRING
      self._package = coda.runtime.Object.EMPTY_MAP

    def _equalsImpl(self, other):
      return (super()._equalsImpl(other) and
        self._path == other._path and
        self._package == other._package)

    def _hashImpl(self):
      return hash((super()._hashImpl(),
        self._path,
        self._package))

    def _freezeImpl(self, deep=True):
      super()._freezeImpl(deep)
      if type(self._package) is not coda.runtime.FrozenDict:
        self._package = coda.runtime.FrozenDict(self._package)

    def _writeFields(self, encoder):
      if self.hasPath():
        encoder.writeFieldHeader('path', 1)
        encoder.writeString(self._path)
      if len(self._package):
        encoder.writeFieldHeader('package', 2)
        encoder.writeBeginMap(5, 5, len(self._package))
        for key, val in self._package.items():
          encoder.writeString(key)
          encoder.writeString(val)
        encoder.writeEndMap()

    def merge(self, src):
      if src.hasPath():
        self.setPath(src.getPath())
      self.getMutablePackage().update(src.getPackage())
      return self

    def hasPath(self):
      return self._isPresent('path')

    def getPath(self):
      return self._path

    def setPath(self, path):
      self.checkMutable()
      self._path = path
      self._setPresent('path')
      return self

    def clearPath(self):
      self.checkMutable()
      self._path = coda.runtime.Object.EMPTY_STRING
      self._clearPresent('path')
      return self

    def getPackage(self):
      return self._package

    def getMutablePackage(self):
      self.checkMutable()
      if self._package is coda.runtime.Object.EMPTY_MAP:
        self._package = {}
      return self._package

    def setPackage(self, package):
      self.checkMutable()
      self._package = package
      return self

    def clearPackage(self):
      self.checkMutable()
      self._package = coda.runtime.Object.EMPTY_MAP
      return self

  __structs__ = (
    Import,
  )
  __enums__ = ()
  __fields__ = (
    ('name', 1, 2, -1),
    ('directory', 2, 2, -1),
    ('package', 3, 2, -1),
    ('options', 4, 22, -1),
    ('structs', 5, 5, -1),
    ('enums', 6, 3, -1),
    ('extensions', 7, 4, -1),
    ('imports', 8, 8, -1),
  )
  __extensions__ = ()
  TYPE_ID = None

  def __init__(self):
    super().__init__()
    self._name = coda.runtime.Object.EMPTY_STRING
    self._directory = coda.runtime.Object.EMPTY_STRING
    self._package = coda.runtime.Object.EMPTY_STRING
    self._options = FileOptions.defaultInstance()
    self._structs = coda.runtime.Object.EMPTY_LIST
    self._enums = coda.runtime.Object.EMPTY_LIST
    self._extensions = coda.runtime.Object.EMPTY_LIST
    self._imports = coda.runtime.Object.EMPTY_LIST

  def _equalsImpl(self, other):
    return (super()._equalsImpl(other) and
      self._name == other._name and
      self._directory == other._directory and
      self._package == other._package and
      self._options == other._options and
      self._structs == other._structs and
      self._enums == other._enums and
      self._extensions == other._extensions and
      self._imports == other._imports)

  def _hashImpl(self):
    return hash((super()._hashImpl(),
      self._name,
      self._directory,
      self._package,
      self._options,
      self._structs,
      self._enums,
      self._extensions,
      self._imports))

  def _freezeImpl(self, deep=True):
    super()._freezeImpl(deep)
    if deep and self._options.isMutable():
      self._options.freeze(deep)
    if type(self._structs) is not tuple:
      self._structs = tuple(self._structs)
    if type(self._enums) is not tuple:
      self._enums = tuple(self._enums)
    if type(self._extensions) is not tuple:
      self._extensions = tuple(self._extensions)
    if type(self._imports) is not tuple:
      self._imports = tuple(self._imports)

  def _writeFields(self, encoder):
    if self.hasName():
      encoder.writeFieldHeader('name', 1)
      encoder.writeString(self._name)
    if self.hasDirectory():
      encoder.writeFieldHeader('directory', 2)
      encoder.writeString(self._directory)
    if self.hasPackage():
      encoder.writeFieldHeader('package', 3)
      encoder.writeString(self._package)
    if self.hasOptions():
      encoder.writeFieldHeader('options', 4)
      encoder.writeStruct(self._options)
    if len(self._structs):
      encoder.writeFieldHeader('structs', 5)
      encoder.writeBeginList(30, len(self._structs))
      for val in self._structs:
        encoder.writeStruct(val, True)
      encoder.writeEndList()
    if len(self._enums):
      encoder.writeFieldHeader('enums', 6)
      encoder.writeBeginList(30, len(self._enums))
      for val in self._enums:
        encoder.writeStruct(val, True)
      encoder.writeEndList()
    if len(self._extensions):
      encoder.writeFieldHeader('extensions', 7)
      encoder.writeBeginList(30, len(self._extensions))
      for val in self._extensions:
        encoder.writeStruct(val, True)
      encoder.writeEndList()
    if len(self._imports):
      encoder.writeFieldHeader('imports', 8)
      encoder.writeBeginList(30, len(self._imports))
      for val in self._imports:
        encoder.writeStruct(val)
      encoder.writeEndList()

  def merge(self, src):
    if src.hasName():
      self.setName(src.getName())
    if src.hasDirectory():
      self.setDirectory(src.getDirectory())
    if src.hasPackage():
      self.setPackage(src.getPackage())
    if src.hasOptions():
      self.setOptions(src.getOptions())
    self.getMutableStructs().extend(src.getStructs())
    self.getMutableEnums().extend(src.getEnums())
    self.getMutableExtensions().extend(src.getExtensions())
    self.getMutableImports().extend(src.getImports())
    return self

  def hasName(self):
    return self._isPresent('name')

  def getName(self):
    return self._name

  def setName(self, name):
    self.checkMutable()
    self._name = name
    self._setPresent('name')
    return self

  def clearName(self):
    self.checkMutable()
    self._name = coda.runtime.Object.EMPTY_STRING
    self._clearPresent('name')
    return self

  def hasDirectory(self):
    return self._isPresent('directory')

  def getDirectory(self):
    return self._directory

  def setDirectory(self, directory):
    self.checkMutable()
    self._directory = directory
    self._setPresent('directory')
    return self

  def clearDirectory(self):
    self.checkMutable()
    self._directory = coda.runtime.Object.EMPTY_STRING
    self._clearPresent('directory')
    return self

  def hasPackage(self):
    return self._isPresent('package')

  def getPackage(self):
    return self._package

  def setPackage(self, package):
    self.checkMutable()
    self._package = package
    self._setPresent('package')
    return self

  def clearPackage(self):
    self.checkMutable()
    self._package = coda.runtime.Object.EMPTY_STRING
    self._clearPresent('package')
    return self

  def hasOptions(self):
    return self._isPresent('options')

  def getOptions(self):
    return self._options

  def getMutableOptions(self):
    self.checkMutable()
    if self._options is FileOptions.defaultInstance() or not self._options.isMutable():
      self._setPresent('options')
      self._options = self._options.shallowCopy()
    return self._options

  def setOptions(self, options):
    self.checkMutable()
    self._options = options
    self._setPresent('options')
    return self

  def clearOptions(self):
    self.checkMutable()
    self._options = FileOptions.defaultInstance()
    self._clearPresent('options')
    return self

  def getStructs(self):
    return self._structs

  def getMutableStructs(self):
    self.checkMutable()
    if self._structs is coda.runtime.Object.EMPTY_LIST:
      self._structs = []
    return self._structs

  def setStructs(self, structs):
    self.checkMutable()
    self._structs = structs
    return self

  def clearStructs(self):
    self.checkMutable()
    self._structs = coda.runtime.Object.EMPTY_LIST
    return self

  def getEnums(self):
    return self._enums

  def getMutableEnums(self):
    self.checkMutable()
    if self._enums is coda.runtime.Object.EMPTY_LIST:
      self._enums = []
    return self._enums

  def setEnums(self, enums):
    self.checkMutable()
    self._enums = enums
    return self

  def clearEnums(self):
    self.checkMutable()
    self._enums = coda.runtime.Object.EMPTY_LIST
    return self

  def getExtensions(self):
    return self._extensions

  def getMutableExtensions(self):
    self.checkMutable()
    if self._extensions is coda.runtime.Object.EMPTY_LIST:
      self._extensions = []
    return self._extensions

  def setExtensions(self, extensions):
    self.checkMutable()
    self._extensions = extensions
    return self

  def clearExtensions(self):
    self.checkMutable()
    self._extensions = coda.runtime.Object.EMPTY_LIST
    return self

  def getImports(self):
    return self._imports

  def getMutableImports(self):
    self.checkMutable()
    if self._imports is coda.runtime.Object.EMPTY_LIST:
      self._imports = []
    return self._imports

  def setImports(self, imports):
    self.checkMutable()
    self._imports = imports
    return self

  def clearImports(self):
    self.checkMutable()
    self._imports = coda.runtime.Object.EMPTY_LIST
    return self

FILE = coda.runtime.createFile('descriptors.coda', 'data', 'coda.descriptors',
  structs = (
    Value, BoolValue, IntegerValue, StringValue, ListValue, Options,
    FileOptions, StructOptions, FieldOptions, MethodOptions, EnumOptions, Type,
    BooleanType, IntegerType, FloatType, DoubleType, StringType, BytesType,
    CollectionType, ListType, SetType, MapType, ModifiedType, DeclType,
    StructType, EnumType, ExtensionField, FileDescriptor,
  ),
  enums = (
    TypeKind,
  ),
  types = lambda t:(
    t.BOOL,
    t.I32,
    t.STRING,
    t.ListType().setElementType(t.ModifiedType().setElementType(EnumType.DESCRIPTOR).setShared(True)),
    t.ListType().setElementType(t.ModifiedType().setElementType(ExtensionField.DESCRIPTOR).setShared(True)),
    t.ListType().setElementType(t.ModifiedType().setElementType(StructType.DESCRIPTOR).setShared(True)),
    t.ListType().setElementType(EnumType.Value.DESCRIPTOR),
    t.ListType().setElementType(ExtensionField.DESCRIPTOR),
    t.ListType().setElementType(FileDescriptor.Import.DESCRIPTOR),
    t.ListType().setElementType(StructType.Field.DESCRIPTOR),
    t.ListType().setElementType(StructType.Param.DESCRIPTOR),
    t.ListType().setElementType(Value.DESCRIPTOR),
    t.MapType().setKeyType(t.STRING).setValueType(t.BOOL),
    t.MapType().setKeyType(t.STRING).setValueType(t.STRING),
    t.MapType().setKeyType(t.STRING).setValueType(t.ListType().setElementType(t.STRING)),
    t.ModifiedType().setElementType(EnumOptions.DESCRIPTOR).setShared(True),
    t.ModifiedType().setElementType(FieldOptions.DESCRIPTOR).setShared(True),
    t.ModifiedType().setElementType(FileDescriptor.DESCRIPTOR).setShared(True),
    t.ModifiedType().setElementType(MethodOptions.DESCRIPTOR).setShared(True),
    t.ModifiedType().setElementType(StructOptions.DESCRIPTOR).setShared(True),
    t.ModifiedType().setElementType(StructType.DESCRIPTOR).setShared(True),
    t.ModifiedType().setElementType(Type.DESCRIPTOR).setShared(True),
    FileOptions.DESCRIPTOR,
    StructType.DESCRIPTOR,
    Value.DESCRIPTOR,
  ),
  options = lambda d:(
    d.FieldOptions().setNullable(True),
    d.FileOptions().setPackage({'cpp': 'coda::descriptors', 'java': 'coda.descriptors', 'python': 'coda.runtime.descdata'}).setOuterClass({'java': 'Descriptors'}).setFilepath({'cpp': 'coda/runtime/descriptors_generated'}).setImports({'cpp': ['coda/runtime/descriptors_mixin.h']}),
    d.StructOptions().setAllowSubtypes(True),
    d.StructOptions().setMixin({'cpp': 'coda::descriptors::DeclTypeMixin', 'python.python3': 'coda.runtime.typemixins.DeclTypeMixin'}),
    d.StructOptions().setMixin({'cpp': 'coda::descriptors::TypeMixin', 'python.python3': 'coda.runtime.typemixins.TypeMixin'}).setShared(True),
    d.StructOptions().setMixin({'python.python3': 'coda.runtime.typemixins.BooleanTypeMixin'}),
    d.StructOptions().setMixin({'python.python3': 'coda.runtime.typemixins.BytesTypeMixin'}),
    d.StructOptions().setMixin({'python.python3': 'coda.runtime.typemixins.DoubleTypeMixin'}),
    d.StructOptions().setMixin({'python.python3': 'coda.runtime.typemixins.FloatTypeMixin'}),
    d.StructOptions().setMixin({'python.python3': 'coda.runtime.typemixins.IntegerTypeMixin'}),
    d.StructOptions().setMixin({'python.python3': 'coda.runtime.typemixins.ListTypeMixin'}),
    d.StructOptions().setMixin({'python.python3': 'coda.runtime.typemixins.MapTypeMixin'}),
    d.StructOptions().setMixin({'python.python3': 'coda.runtime.typemixins.ModifiedTypeMixin'}),
    d.StructOptions().setMixin({'python.python3': 'coda.runtime.typemixins.SetTypeMixin'}),
    d.StructOptions().setMixin({'python.python3': 'coda.runtime.typemixins.StringTypeMixin'})
  ), fileOptions=1, descriptors=globals())

__all__ = [
  'Value', 'BoolValue', 'IntegerValue', 'StringValue', 'ListValue', 'Options',
  'FileOptions', 'StructOptions', 'FieldOptions', 'MethodOptions',
  'EnumOptions', 'Type', 'BooleanType', 'IntegerType', 'FloatType',
  'DoubleType', 'StringType', 'BytesType', 'CollectionType', 'ListType',
  'SetType', 'MapType', 'ModifiedType', 'DeclType', 'StructType', 'EnumType',
  'ExtensionField', 'FileDescriptor', 'TypeKind'
]
